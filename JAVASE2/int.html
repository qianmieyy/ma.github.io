<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1648"/>

<div>
<span><div>1. 基本数据类型和包装类</div><div>1)八个基本数据类型的包装类</div><div>基本数据类型 包装类</div><div>byte  Byte</div><div>boolean  Boolean</div><div>short  Short</div><div>char  Character</div><div>int  Integer</div><div>long  Long</div><div>float  Float</div><div>double  Double</div><div>list.add()</div><div>2)为什么为基本类型引入包装类</div><div>基本数据类型有方便之处，简单、高效。</div><div>但是 Java中的基本数据类型却是不面向对象的（没有属性、方法），这在实际使用时存在很多</div><div>的不便（比如集合的元素只能是 Object）。</div><div>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行包装，这样八个</div><div>和基本数据类型对应的类统称为包装类 (Wrapper Class)。</div><div>3) 包装类和基本数据类型之间的转换</div><div>包装类 ------ wrapperInstance.xxxValue() -----------&gt; 基本数据类型</div><div>包装类 &lt;-----new WrapperClass(primitive) new WrapperClass(string)------ 基本数据类型</div><div>4)自动装箱和自动拆箱</div><div>JDK1.5 提供了自动装箱（ autoboxing）和自动拆箱（ autounboxing）功能 , 从而实现了包装类和</div><div>基本数据类型之间的自动转换</div><div>5)、包装类还可以实现基本类型变量和字符串之间的转换</div><div>基本类型变量 ------------String.valueof()------------&gt; 字符串</div><div>基本类型变量 &lt;------------WrapperClass.parseXxx(string)------------ 字符串</div><div><br/></div><div><br/></div><div>2. Integer 与 int 的区别</div><div>int 是 java 提供的 8 种原始数据类型之一。 Java为每个原始类型提供了封装类， Integer 是 java 为</div><div>int 提供的封装类。 int 的默认值为 0，而 Integer 的默认值为 null ，即 Integer 可以区分出未赋值和值为</div><div>0 的区别， int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为 0 的区别，</div><div>则只能使用 Integer。在 JSP开发中， Integer 的默认为 null ，所以用 el 表达式在文本框中显示时，值为</div><div>空白字符串，而 int 默认的默认值为 0，所以用 el 表达式在文本框中显示时，结果为 0，所以， int 不</div><div>适合作为 web 层的表单数据的类型。</div><div>在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null 而</div><div>判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中设置其</div><div>unsaved-value属性为 0。</div><div>另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数， Integer 中还</div><div>定义了表示整数的最大值和最小值的常量。</div><div><br/></div><div><br/></div><div>3. String 类为什么是 final 的</div><div>1) 为了效率。若允许被继承，则其高度的 被使用率可能会降低程序的性能。</div><div>2) 为了安全。 JDK 中提供的好多核心类比如 String，这类的类的内部好多方法的实现都不是 java</div><div>编程语言本身编写的， 好多方法都是调用的操作系统本地的 API ，这就是著名的 “本地方法调用 ”，</div><div>也只有这样才能做事，这种类是非常底层的， 和操作系统交流频繁的，那么如果这种类可以被</div><div>继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码</div><div>什么的， 这不就成了核心病毒了么？</div><div>3) 不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完</div><div>了，不想让我们随便能改，其实说白了还是安全性， 如果随便能改了，那么 java 编写的程序肯</div><div>定就很不稳定，你可以保证自己不乱改， 但是将来一个项目好多人来做，管不了别人，再说有</div><div>时候万一疏忽了呢？他也不是估计的， 所以这个安全性是很重要的， java 和 C++相比，优点之</div><div>一就包括这一点；</div><div><br/></div><div><br/></div><div>4. String 、StringBuffer 、StringBuilder 区别与联系</div><div>1) String 类是不可变类，即一旦一个 String 对象被创建后，包含在这个对象中的字符序列是不可改</div><div>变的，直至这个对象销毁。</div><div>2) StringBuffer 类则代表一个字符序列可变的字符串， 可以通过 append、insert、reverse、setChartAt、</div><div>setLength 等方法改变其内容。一旦生成了最终的字符串，调用 toString 方法将其转变为 String</div><div>3) JDK1.5 新增了一个 StringBuilder 类，与 StringBuffer 相似，构造方法和方法基本相同。不同是</div><div>StringBuffer 是线程安全的，而 StringBuilder 是线程不安全的，所以性能略高。通常情况下，创建</div><div>一个内容可变的字符串，应该优先考虑使用 StringBuilder</div><div><br/></div><div><br/></div><div>5. String 类型是基本数据类型吗？基本数据类型有哪些</div><div>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。</div><div>java.lang.String 类是引用数据类型，并且是 final 类型的，因此不可以继承这个类、不能修改这个类。</div><div>为了提高效率节省空间，我们应该用 StringBuffer 类</div><div><br/></div><div><br/></div><div>6. String  s=&quot;Hello&quot;;s=s+&quot;world!&quot;; 执行后， s 内容是否改变？</div><div>没有。因为 String 被设计成不可变 (immutable) 类，所以它的所有对象都是不可变对象。在这段代</div><div>码中， s原先指向一个 String 对象，内容是 &quot;Hello&quot; ，然后我们对 s进行了 +操作，那么 s 所指向的那</div><div>个对象是否发生了改变呢？答案是没有。这时， s不指向原来那个对象了，而指向了另一个 String 对</div><div>象，内容为 &quot;Hello world!&quot; ，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。</div><div>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不</div><div>可预见的修改， 那么使用 String 来代表字符串的话会引起很大的内存开销。 因为 String 对象建立之后</div><div>不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。这时，应该考虑使用</div><div>StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。 并且， 这两种类的对</div><div>象转换十分容易。</div><div>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在</div><div>构造器中对一个名叫 s的 String 引用变量进行初始化，把它设置为初始值，应当这样做：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public class Demo {</div><div>private String s;</div><div>...</div><div>public Demo {</div><div>s = &quot;Initial Value&quot;;</div><div>}</div><div>...</div><div>}</div></div><div><br/></div><div>而非</div><div>s = new String(&quot;Initial Value&quot;);</div><div>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不</div><div>可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，多次调用上面</div><div>的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。</div><div>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同， Java认为它们代表同一个 String</div><div>对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。</div><div>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多 Java标准类库</div><div>中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的</div><div>值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并</div><div>发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造</div><div>成性能上的问题。所以 Java标准类库还提供了一个可变版本，即 StringBuffer 。</div><div><br/></div><div><br/></div><div>7. String s = new String(&quot;xyz&quot;); 创建几个 String Object?</div><div>两个或一个， ”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量 ”xyz”不管出现多少遍，都是</div><div>缓冲区中的那一个。 New String 每写一遍，就创建一个新的对象，它一句那个常量 ”xyz”对象的内容来</div><div>创建出一个新 String 对象。如果以前就用过 ’xyz’，这句代表就不会创建 ”xyz”自己了， 直接从缓冲区拿。</div><div><br/></div><div><br/></div><div>8. 下面这条语句一共创建了多少个对象： String</div><div>s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;</div><div>答：对于如下代码：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>String s1 = &quot;a&quot;;</div><div>String s2 = s1 + &quot;b&quot;;</div><div>String s3 = &quot;a&quot; + &quot;b&quot;;</div><div>System.out.println(s2 == &quot;ab&quot;);</div><div>System.out.println(s3 == &quot;ab&quot;);</div></div><div><br/></div><div>第一条语句打印的结果为 false，第二条语句打印的结果为 true，这说明 javac 编译可以对字符串常</div><div>量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加</div><div>号，直接将其编译成一个这些常量相连的结果。</div><div>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个 ”abcd”的字符串，所以，</div><div>上面的代码应该只创建了一个 String 对象。写如下两行代码，</div><div>String s = &quot;a&quot; + &quot;b&quot; + &quot;c&quot; + &quot;d&quot;;</div><div>System.out.println(s == &quot;abcd&quot;);</div><div>最终打印的结果应该为 true。</div><div><br/></div><div><br/></div><div>9. java.sql.Date 和 java.util.Date 的联系和区别</div><div>java.sql.Date 是 java.util.Date 的子类，是一个包装了毫秒值的瘦包装器， 允许 JDBC 将毫秒值标</div><div>识为 SQL DATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与</div><div>SQL DATE 的定义一致，由 java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置</div><div>为与该实例相关的特定时区中的零来 “规范化 ”。 说白了， java.sql.Date 就是与数据库 Date 相对应的一</div><div>个类型，而 java.util.Date 是纯 java的 Date。</div><div>JAVA 里提供的日期和时间类， java.sql.Date 和 java.sql.Time,只会从数据库里读取某部分值，这有</div><div>时会导致丢失数据。例如一个包含 2002/05/22 5:00:57 PM 的字段，读取日期时得到的是 2002/05/22,</div><div>而读取时间时得到的是 5:00:57 PM. 你需要了解数据库里存储时间的精度。 有些数据库， 比如 MySQL,</div><div>精度为毫秒，然而另一些数据库，包括 Oracle,存储 SQL DATE 类型数据时，毫秒部分的数据是不保</div><div>存的。以下操作中容易出现不易被发现的 BUG：获得一个 JAVA 里的日期对象。 从数据库里读取日</div><div>期 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象用 Equals 方</div><div>法可能返回 false。.sql.Timestamp 类比 java.util.Date 类精确度要高。这个类包了一个 getTime()方法，</div><div>但是它不会返回额外精度部分的数据，因此必须使用 ...</div><div>总之， java.util.Date 就是 Java的日期对象，而 java.sql.Date 是针对 SQL 语句使用的，只包含日</div><div>期而没有时间部分。</div><div><br/></div><div><br/></div><div>10. 使用递归算法输出某个目录下所有文件和子目录列表</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>import java.io.File;</div><div>public class $ {</div><div>public static void main(String[] args) {</div><div>String path = &quot;D:/301SXT&quot;;</div><div>test(path);</div><div>}</div><div>private static void test(String path) {</div><div>File f = new File(path);</div><div>File[] fs = f.listFiles();</div><div>if (fs == null ) {</div><div>return ;</div><div>}</div><div>for (File file : fs) {</div><div>if (file.isFile()) {</div><div>System.out .println(file.getPath());</div><div>} else {</div><div>test(file.getPath());</div><div>}</div><div>}</div><div>}</div><div>}</div></div><div><br/></div></span>
</div></body></html> 