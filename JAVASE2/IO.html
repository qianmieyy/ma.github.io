<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1658"/>

<div>
<span><div>1. 输入流和输出流联系和区别， 节点流和处理流联系和区别</div><div>首先，你要明白什么是“流”。直观地讲，流就像管道一样，在程序和文件之间，输入输出的</div><div>方向是针对程序而言，向程序中读入东西，就是输入流，从程序中向外读东西，就是输出流。输入流</div><div>是得到数据，输出流是输出数据。</div><div>而节点流，处理流是流的另一种划分，按照功能不同进行的划分。节点流，可以从或向一个特</div><div>定的地方 ( 节点 ) 读写数据。处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实</div><div>现数据读写。 如 BufferedReader 。处理流的构造方法总是要带一个其他的流对象做参数。 一个流对象</div><div>经过其他流的多次包装，称为流的链接。</div><div><br/></div><div><br/></div><div>2. 字符流字节流联系区别；什么时候使用字节流和字符流 ?</div><div>字符流和字节流是流的一种划分，按处理照流的数据单位进行的划分。两类都分为输入和输出操</div><div>作。在字节流中输出数据主要是使用 OutputStream 完成，输入使的是 InputStream ，在字符流中输出</div><div>主要是使用 Writer 类完成，输入流主要使用 Reader 类完成。这四个都是抽象类。字符流处理的单元</div><div>为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操</div><div>作字节和字节数组。字节流是最基本的，所有的 InputStrem 和 OutputStream 的子类都是 , 主要用在</div><div>处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是</div><div>按 虚 拟 机 的 编 码 来 处 理 ， 也 就 是 要 进 行 字 符 集 的 转 化 这 两 个 之 间 通 过</div><div>InputStreamReader,OutputStreamWriter 来关联，实际上是通过 byte[] 和 String 来关联的。</div><div><br/></div><div><br/></div><div>3. 列举常用字节输入流和输出流并说明其特点，至少 5 对。</div><div>FileInputStream  从文件系统中的某个文件中获得输入字节。</div><div>ByteArrayInputStream 包含一个内部缓冲区，该缓冲区包含从流中读取的字节。内部计数器跟踪</div><div>read 方法要提供的下一个字节。</div><div>FilterInputStream 包含其他一些输入流， 它将这些流用作其基本数据源， 它可以直接传输数据或提</div><div>供一些额外的功能。 FilterInputStream  类本身只是简单地重写那些将所有请求传递给所包含输入流</div><div>的 InputStream  的所有方法。 FilterInputStream  的子类可进一步重写这些方法中的一些方法，并</div><div>且还可以提供一些额外的方法和字段。</div><div>ObjectInputStream  对以前使用 ObjectOutputStream  写入的基本数据和对象进行反序列化。</div><div>ObjectOutputStream  和 ObjectInputStream  分别与 FileOutputStream  和 FileInputStream  一起</div><div>使用时，可以为应用程序提供对对象图形的持久存储。 ObjectInputStream  用于恢复那些以前序列化</div><div>的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实</div><div>参和形参。</div><div>StringBufferInputStream 此类允许应用程序创建输入流，在该流中读取的字节由字符串内容提供。</div><div>应用程序还可以使用 ByteArrayInputStream  从 byte  数组中读取字节。 只有字符串中每个字符的低</div><div>八位可以由此类使用。</div><div>ByteArrayOutputStream 此类实现了一个输出流，其中的数据被写入一个 byte  数组。缓冲区会随着</div><div>数据的不断写入而自动增长。可使用 toByteArray()  和 toString()  获取数据。</div><div>FileOutputStream 文件输出流是用于将数据写入 File  或 FileDescriptor  的输出流。文件是否可</div><div>用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream （或其他</div><div>文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方</div><div>法将失败。</div><div>FilterOutputStream 类是过滤输出流的所有类的超类。这些流位于已存在的输出流（基础 输出流）</div><div>之上，它们将已存在的输出流作为其基本数据接收器，但可能直接传输数据或提供一些额外的功能。</div><div>FilterOutputStream  类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream</div><div>的所有方法。 FilterOutputStream  的子类可进一步地重写这些方法中的一些方法，并且还可以提供</div><div>一些额外的方法和字段。</div><div>ObjectOutputStream  将 Java 对象的基本数据类型和图形写入 OutputStream 。可以使用</div><div>ObjectInputStream  读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网</div><div>络套接字流，则可以在另一台主机上或另一个进程中重构对象。</div><div>PipedOutputStream 可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送</div><div>端。通常，数据由某个线程写入 PipedOutputStream  对象，并由其他线程从连接的 PipedInputStream</div><div>读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从</div><div>连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于毁坏状态。</div><div><br/></div><div><br/></div><div>4. 说明缓冲流的优点和原理</div><div>不带缓冲的流的工作原理：它读取到一个字节 / 字符，就向用户指定的路径写出去，读一个写一</div><div>个，所以就慢了。带缓冲的流的工作原理：读取到一个字节 / 字符，先不输出，等凑足了缓冲的最大</div><div>容量后一次性写出去，从而提高了工作效率</div><div>优点：减少对硬盘的读取次数，降低对硬盘的损耗。</div><div><br/></div><div><br/></div><div>5. 序列化的定义、实现和注意事项</div><div>想把一个对象写在硬盘上或者网络上，对其进行序列化，把他序列化成为一个字节流。</div><div>实现和注意事项：</div><div>1) 实现接口 Serializable Serializable 接口中没有任何的方法，实现该接口的类不需要实现额</div><div>外的方法。</div><div>2) 如果对象中的某个属性是对象类型，必须也实现 Serializable 接口才可以</div><div>3) 序列化对静态变量无效</div><div>4) 如果不希望某个属性参与序列化，不是将其 static ，而是 transient</div><div>5) 串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存</div><div>6) 序列化版本不兼容</div><div><br/></div><div><br/></div><div>6. 使用 IO 流完成文件夹复制（结合递归）</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>import java.io.*;</div><div>/**</div><div>30</div><div>* CopyDocJob 定义了实际执行的任务，即</div><div>* 从源目录拷贝文件到目标目录</div><div>*/</div><div>public class CopyDir2 {</div><div>public static void main(String[] args) {</div><div>try {</div><div>copyDirectiory(&quot;d:/301sxt&quot;,&quot;d:/301sxt2&quot;);</div><div>} catch (IOException e) {</div><div>e.printStackTrace();</div><div>}</div><div>}</div><div>/**</div><div>* 复制单个文件</div><div>* @param sourceFile  源文件</div><div>* @param targetFile  目标文件</div><div>* @throws IOException</div><div>*/</div><div>private static void copyFile(File sourceFil e, File targetFile) throws IOException {</div><div>BufferedInputStream inBuff = null;</div><div>BufferedOutputStream outBuff = null;</div><div>try {</div><div>// 新建文件输入流</div><div>inBuff = new BufferedInputStream(new FileInputStream(sourceFile));</div><div>// 新建文件输出流</div><div>outBuff = new BufferedOutputStream(new FileOutputStream(targetFile));</div><div>// 缓冲数组</div><div>byte[] b = new byte[1024 * 5];</div><div>int len;</div><div>while ((len = inBuff.read(b)) != -1) {</div><div>outBuff.write(b, 0, len);</div><div>}</div><div>// 刷新此缓冲的输出流</div><div>outBuff.flush();</div><div>} finally {</div><div>// 关闭流</div><div>if (inBuff != null)</div><div>inBuff.cl ose();</div><div>if (outBuff != null)</div><div>outBuff.close();</div><div>}</div><div>}</div><div>/**</div><div>* 复制目录</div><div>* @param sourceDir  源目录</div><div>* @param targetDir  目标目录</div><div>* @throws IOException</div><div>*/</div><div>private  static void  copyDirectiory(String  sourceDir,  String targetDir)  throws</div><div>IOException {</div><div>//  检查源目录</div><div>File fSourceDir = new File(sourceDir);</div><div>if(!fSourceDir.exists() || !fSourceDir.isDirectory()){</div><div>return;</div><div>}</div><div>// 检查目标目录，如不存在则创建</div><div>File fTargetDir = new File(targetDir);</div><div>if(!fTargetDir.exists()){</div><div>fTargetDir.mkdirs();</div><div>}</div><div>//  遍历源目录下的文件或目录</div><div>File[] file = fSourceDir.listFiles();</div><div>for (int i = 0; i &lt; file.length; i++) {</div><div>if (file[i].isFil e()) {</div><div>//  源文件</div><div>File sourceFile = file[i];</div><div>//  目标文件</div><div>File targetFile = new File(fTargetDir, file[i].getName());</div><div>copyFile(sourceFil e, targetFile);</div><div>}</div><div>// 递归复制子目录</div><div>if (file[i].isDirectory()) {</div><div>//  准备复制的源文件夹</div><div>String subSourceDir = sourceDir + File.separator + fil e[i].getName();</div><div>//  准备复制的目标文件夹</div><div>String subTargetDir = targetDir + File.separator + file[i].getName();</div><div>//  复制子目录</div><div>copyDirectiory(subSourceDir, subTargetDir);</div><div>}</div><div>}</div><div>}</div><div>}</div></div><div><br/></div></span>
</div></body></html> 