<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1636"/>

<div>
<span><div>1. 类和对象的关系</div><div>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。</div><div>类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</div><div>类和对象好比图纸和实物的关系，模具和铸件的关系。</div><div>比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</div><div>小明就是一个具体的人，也就是实例，他的属性是具体的身高 200cm，体重 180kg，他做的方法是具体的</div><div>吃了一碗白米饭，说了“ 12345”这样一句话。</div><div><br/></div><div>2. 面向过程和面向对象的区别</div><div>两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向</div><div>对象开发思想。</div><div>比喻</div><div>蒋介石和毛泽东分别是面向过程和面向对象的杰出代表，这样充分说明，在解决复制问题时，面向对象有</div><div>更大的优越性。</div><div>面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的</div><div>灵活性。 饭不满意就换饭， 菜不满意换菜。 用软件工程的专业术语就是 “可维护性” 比较好，“饭” 和“菜”</div><div>的耦合度比较低。</div><div>区别</div><div>1. 编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，</div><div>然后通过实例化类、执行方法来完成功能。</div><div>2. 封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</div><div>3. 面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</div><div>3. 方法重载和方法重写（覆盖）的区别</div><div><br/></div><div>4. this 和 super 关键字的作用</div><div>this 是对象内部指代自身的引用</div><div>1) this 可以调用成员变量，通常用于解决成员变量和局部变量同名冲突</div><div>2) this 可以调用成员方法</div><div>3) this 可以在构造方法中调用重载的构造方法，且必须是构造方法的第一条语句。</div><div>super代表对当前对象的直接父类对象的引用</div><div>1) super 可以调用直接父类的成员变量（注意权限修饰符的影响，比如不能访问 private 成员）</div><div>2) super 可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问 private 成员）</div><div>3) super 可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</div><div><br/></div><div>5. static 关键字的作用（修饰变量、方法、代码块）</div><div>static 可以修饰变量、方法、代码块和内部类</div><div>1. static 属性属于这个类所有，即由该类创建的所有对象共享同一个 static 属性。可以对象创建后</div><div>通过对象名 .属性名和类名 .属性名两种方式来访问。也可以在没有创建任何对象之前通过类名 .</div><div>属性名的方式来访问。</div><div>.static 变量和非 static 变量的区别 (都是成员变量，不是局部变量 )</div><div>1.在内存中份数不同</div><div>不管有多少个对象， static 变量只有 1 份。对于每个对象，实例变量都会有单独的一份</div><div>static 变量是属于整个类的，也称为类变量。而非静态变量是属于对象的，也称为实例变量</div><div>2.在内存中存放的位置不同</div><div>静态变量存在方法区中， 实例变量存在堆内存中 *</div><div>3.访问的方式不同</div><div>实例变量： 对象名 .变量名 stu1.name=&quot;小明明 &quot;;</div><div>静态变量：对象名 .变量名 stu1.schoolName=&quot;西二旗小学 &quot;; 不推荐如此使用</div><div>类名 .变量名 Student.schoolName=&quot; 东三旗小学 &quot;; 推荐使用</div><div>4.在内存中分配空间的时间不同</div><div>实例变量：创建对象的时候才分配了空间。静态变量：第一次使用类的时候</div><div>Student.schoolName=&quot; 东三旗小学 &quot;;或者 Student stu1 = new Student(&quot; 小明 &quot;,&quot; 男&quot;,20,98);</div><div>2. static 方法也可以通过对象名 .方法名和类名 .方法名两种方式来访问</div><div>3. static 代码块。当类被第一次使用时（可能是调用 static 属性和方法，或者创建其对象）执行静</div><div>态代码块，且只被执行一次，主要作用是实现 static 属性的初始化。</div><div>4. static 内部类：属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员</div><div>（变量或者方法）， .可以访问外部类的静态成员</div><div><br/></div><div>6. final 和 abstract 关键字的作用</div><div>final 和 abstract是功能相反的两个关键字，可以对比记忆</div><div>1) abstract 可以用来修饰类和方法，不能用来修饰属性和构造方法；使用 abstract 修饰的类是抽象</div><div>类，需要被继承，使用 abstract 修饰的方法是抽象方法，需要子类被重写。</div><div>2) final 可以用来修饰类、方法和属性，不能修饰构造方法。使用 final 修饰的类不能被继承，使用</div><div>final 修饰的方法不能被重写，使用 final 修饰的变量的值不能被修改，所以就成了常量。</div><div>3) 特别注意： final 修饰基本类型变量，其值不能改变。但是 final 修饰引用类型变量，栈内存中的</div><div>引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Test {</div><div>public static void main(String[] args) {</div><div>final Dog dog = new Dog(&quot;欧欧 &quot;);</div><div>dog.name = &quot;美美&quot;;// 正确</div><div>dog = new Dog(&quot;亚亚 &quot;);// 错误</div><div>}</div><div>}</div></div><div><br/></div><div>7. final 、finally 、finalize 的区别</div><div>1) final 修饰符（关键字）如果一个类被声明为 final，意味着它不能再派生出新的子类，不能作为</div><div>父类被继承。将变量或方法声明为 final，可以保证它们在使用中不被改变。被声明为 final 的变</div><div>量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同</div><div>样只能使用，不能重载。</div><div>2) finally 在异常处理时提供 finally 块来执行任何清除操作。如果有 finally 的话，则不管是否发生</div><div>异常， finally 语句都会被执行。</div><div>3) finalize 方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做</div><div>必要清理工作。 finalize() 方法是在垃圾收集器删除对象之前被调用的。它是在 Object 类中定义</div><div>的，因此所有的类都继承了它。 子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。</div><div><br/></div><div>8. 写出 java.lang.Object 类的六个常用方法</div><div>1. public boolean equals(java.lang.Object) 比较内容</div><div>2. public native int hashCode() 哈希码</div><div>3. public java.lang.String toString() 变成字符串</div><div>4. public final native java.lang.Class getClass() 获取类结构信息</div><div>5. protected void finalize() throws java.lang.Throwable  垃圾回收前执行的方法</div><div>6. protected native Object clone() throws java.lang.CloneNotSupportedException  克隆</div><div>7. public final void wait() throws java.lang.InterruptedException  多线程中等待功能</div><div>8. public final native void notify()  多线程中唤醒功能</div><div>9. public final native void notifyAll()  多线程中唤醒所有等待线程的功能</div><div><br/></div><div><br/></div><div>9. private/ 默认 /protected/public 权限修饰符的区别</div><div><img src="object_files/Image.png" type="image/png"/></div><div><img src="object_files/Image [1].png" type="image/png"/></div><div><br/></div><div>类的访问权限只有两种</div><div>public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名 )</div><div>default 默认的 可被同一个包中的类访问。</div><div>成员（成员变量或成员方法）访问权限共有四种 ：</div><div>public 公共的 可以被项目中所有的类访问。 (项目可见性 )</div><div>protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个</div><div>包以及不同包中的子类）访问。（子类可见性）</div><div>default 默认的 被这个类本身访问；被同一个包中的类访问。（包可见性）</div><div>private 私有的 只能被这个类本身访问。（类可见性）</div><div><br/></div><div>10. 继承条件下构造方法的执行过程</div><div>继承条件下构造方法的调用规则如下：</div><div>如果子类的构造方法中没有通过 super 显式调用父类的有参构造方法， 也没有通过 this 显式调</div><div>用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写</div><div>“super(); ” 语句，效果是一样的。</div><div>如果子类的构造方法中通过 super 显式调用父类的有参构造方法，那将执行父类相应构造方</div><div>法，而不执行父类无参构造方法。</div><div>如果子类的构造方法中通过 this 显式调用自身的其他构造方法，在相应构造方法中应用以上</div><div>两条规则。</div><div>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一</div><div>级父类应用，一直到执行顶级父类 Object 类的无参构造方法为止。</div><div><br/></div><div>11. ==和 equals 的区别和联系</div><div>==：</div><div>a)  基本类型，比较的是值</div><div>b)  引用类型，比较的是地址</div><div>c)  不能比较没有父子关系的两个对象</div><div>equals()</div><div>a)  系统类一般已经覆盖了 equals()，比较的是内容。</div><div>b)  用户自定义类如果没有覆盖 equals()，将调用父类的 equals（比如是 Object），而 Object 的</div><div>equals 的比较是地址（ return (this == obj); ）</div><div>c)  用户自定义类需要覆盖父类的 equals()</div><div>注意： Object 的==和 equals 比较的都是地址，作用相同</div><div><br/></div><div>12. 多态的技能点（前提条件，向上转型、向下转型）</div><div>实现多态的三个条件</div><div>1) 继承的存在；（继承是多态的基础，没有继承就没有多态）</div><div>2) 子类重写父类的方法。（多态下会调用子类重写后的方法）</div><div>3) 父类引用变量指向子类对象。（涉及子类到父类的类型转换）</div><div>向上转型 Student person = new Student()</div><div>1) 将一个父类的引用指向一个子类对象，成为向上转型，自动进行类型转换。</div><div>2) 此时通过父类引用变量调用的方法是子类覆盖或继承父类的方法，而不是父类的方法</div><div>3) 此时通过父类引用变量无法调用子类特有的方法</div><div>向下转型 Student stu = (Student)person;</div><div>1) 将一个指向子类对象的引用赋给一个子类的引用，成为向下转型，此时必须进行强制类型转换。</div><div>2) 向下转型必须转换为父类引用指向的真实子类类型， ，否则将出现 ClassCastException，不是任意</div><div>的强制转换</div><div>3) 向下转型时可以结合使用 instanceof 运算符进行强制类型转换，比如出现转换异常。</div><div><br/></div><div><br/></div><div>13. 接口和抽象类的异同之处</div><div>相同点</div><div>抽象类和接口均包含抽象方法，类必须实现所有的抽象方法，否则是抽象类</div><div>抽象类和接口都不能实例化，他们位于继承树的顶端，用来被其他类继承和实现</div><div>两者的区别主要体现在两方面：语法方面和设计理念方面</div><div>语法方面的区别是比较低层次的，非本质的，主要表现在：</div><div>接口中只能定义全局静态常量，不能定义变量。抽象类中可以定义常量和变量。</div><div>接口中所有的方法都是全局抽象方法。抽象类中可以有 0 个、1 个或多个，甚至全部都是抽象方</div><div>法。</div><div>抽象类中可以有构造方法，但不能用来实例化，而在子类实例化是执行，完成属于抽象类的初</div><div>始化操作。接口中不能定义构造方法。</div><div>一个类只能有一个直接父类（可以是抽象类），但可以充实实现多个接口。一个类使用 extends</div><div>来继承抽象类，使用 implements 来实现接口。</div><div>二者的主要区别还是在设计理念上，其决定了某些情况下到底使用抽象类还是接口。</div><div>抽象类体现了一种继承关系，目的是复用代码，抽象类中定义了各个子类的相同代码，可以认</div><div>为父类是一个实现了部分功能的“中间产品”，而子类是“最终产品”。父类和子类之间必须</div><div>存在“ is-a”的关系，即父类和子类在概念本质上应该是相同的。</div><div>接口并不要求实现类和接口在概念本质上一致的，仅仅是实现了接口定义的约定或者能力而已。</div><div>接口定义了“做什么”，而实现类负责完成“怎么做”，体现了功能（规范）和实现分离的原</div><div>则。接口和实现之间可以认为是一种“ has-a的关系”</div><div><br/></div><div><br/></div><div>14. 简述 Java 的垃圾回收机制</div><div>传统的 C/C++语言，需要程序员负责回收已经分配内存。显式回收垃圾回收的缺点：</div><div>1) 程序忘记及时回收，从而导致内存泄露，降低系统性能。</div><div>2) 程序错误回收程序核心类库的内存，导致系统崩溃。</div><div>Java语言不需要程序员直接控制内存回收， 是由 JRE在后台自动回收不再使用的内存， 称为垃圾</div><div>回收机制。</div><div>1) 可以提高编程效率。</div><div>2) 保护程序的完整性。</div><div>3) 其开销影响性能。 Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。</div><div>垃圾回收机制的特点</div><div>1) 垃圾回收机制回收 JVM 堆内存里的对象空间 ,不负责回收栈内存数据。</div><div>2) 对其他物理连接，比如数据库连接、输入流输出流、 Socket连接无能为力。</div><div>3) 垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</div><div>4) 可以将对象的引用变量设置为 null ，暗示垃圾回收机制可以回收该对象。</div><div>5) 现在的 JVM 有多种垃圾回收实现算法，表现各异。</div><div>6) 垃圾回收机制回收任何对象之前，总会先调用它的 finalize 方法（如果覆盖该方法，</div><div>让一个新的引用变量重新引用该对象，则会重新激活对象）。</div><div>7) 程序员可以通过 System.gc()或者 Runtime.getRuntime().gc() 来通知系统进行垃圾回收，</div><div>会有一些效果，但是系统是否进行垃圾回收依然不确定。</div><div>8) 永远不要主动调用某个对象的 finalize 方法，应该交给垃圾回收机制调用。</div><div><br/></div></span>
</div></body></html> 