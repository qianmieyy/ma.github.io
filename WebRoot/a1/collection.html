<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1590"/>

<div>
<span><div><img src="collection_files/Image.png" type="image/png"/></div><div>迭代器（Iterable）：从头到尾数一遍</div><div><br/></div><div><br/></div><div>HashSet就是操作了HashMap</div><div>HashMap的key其实就是set（不可重复）</div><div>HashTable安全synchronized效率低</div><div><br/></div><div><br/></div><div>synchronized同步方法：排队一 一访问</div><div style="WIDTH: 320px"><div><br/></div><div style="font-weight: bold; font-size: 20px;">synchronized ['sɪŋkrənaɪz]</div></div><div><br/></div><div>  </div><div>arrayList</div><div><br/></div><div>LinkedList  :  Vector  synchronized 安全的，效率低</div><div><br/></div><div><br/></div><div><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt"><b>Java</b></span></font><font face="宋体" size="5"><span style="font-size:18pt"><b>集合类</b></span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">18.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类框架的基本接口有哪些？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类里面最基本的接口有：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Collection</span></font><font face="宋体" size="5"><span style="font-size:18pt">：代表一组对象，每一个对象都是它的子元素。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Set</span></font><font face="宋体" size="5"><span style="font-size:18pt">：不包含重复元素的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Collection</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">：有顺序的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">collection</span></font><font face="宋体" size="5"><span style="font-size:18pt">，并且可以包含重复元素。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Map</span></font><font face="宋体" size="5"><span style="font-size:18pt">：可以把键</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(key)</span></font><font face="宋体" size="5"><span style="font-size:18pt">映射到值</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(value)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的对象，键不能重复。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">19.</span></font><font face="宋体" size="5"><span style="font-size:18pt">为什么集合类没有实现</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Cloneable</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Serializable</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">克隆</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(cloning)</span></font><font face="宋体" size="5"><span style="font-size:18pt">或者是序列化</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(serialization)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">20.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是迭代器</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Iterator)</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:4.22mm;min-height: 13pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 11pt;"><font face="宋体" size="5"><span style="font-size:18pt">迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">21.Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">下面列出了他们的区别：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">可用来遍历</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Set</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合，但是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">只能用来遍历</span></font><font face="Verdana" size="5"><span style="font-size:18pt">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">对集合只能是前向遍历，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">既可以前向也可以后向。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">实现了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">22.</span></font><font face="宋体" size="5"><span style="font-size:18pt">快速失败</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(fail-fast)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和安全失败</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(fail-safe)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">java.util</span></font><font face="宋体" size="5"><span style="font-size:18pt">包下面</span></font><font face="Verdana" size="5"><span style="font-size:18pt">      </span></font> <font face="宋体" size="5"><span style="font-size:18pt">的所有的集合类都是快速失败的，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">java.util.concurrent</span></font><font face="宋体" size="5"><span style="font-size:18pt">包下面的所有的类都是安全失败的。快速失败的迭代器会抛出</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">ConcurrentModificationException</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常，而安全失败的迭代器永远不会抛出这样的异常。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">23.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">的工作原理是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">是以键值对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(key-value)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的形式存储元素的。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">需要一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">函数，它使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法来向集合</span></font><font face="Verdana" size="5"><span style="font-size:18pt">/</span></font><font face="宋体" size="5"><span style="font-size:18pt">从集合添加和检索元素。当调用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">put()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的时候，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">会计算</span></font><font face="Verdana" size="5"><span style="font-size:18pt">key</span></font><font face="宋体" size="5"><span style="font-size:18pt">的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">值，然后把键值对存储在集合中合适的索引上。如果</span></font><font face="Verdana" size="5"><span style="font-size:18pt">key</span></font><font face="宋体" size="5"><span style="font-size:18pt">已经存在了，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">value</span></font><font face="宋体" size="5"><span style="font-size:18pt">会被更新成新值。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">的一些重要的特性是它的容量</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(capacity)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，负载因子</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(load factor)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和扩容极限</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(threshold resizing)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">24.hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的重要性体现在什么地方？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">的精确性和正确性是至关重要的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">25.HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">都实现了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Map</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口，因此很多特性非常相似。但是，他们有以下不同点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">允许键和值是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">不允许键或者值是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">是同步的，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">不是。因此，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">更适合于单线程环境，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">适合于多线程环境。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了可供应用迭代的键的集合，因此，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">是快速失败的。另一方面，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了对键的列举</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Enumeration)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: circle;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-family: Courier New; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">一般认为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">是一个遗留的类。</span></font></li></ul></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">26.</span></font><font face="宋体" size="5"><span style="font-size:18pt">数组</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Array)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和列表</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(ArrayList)</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？什么时候应该使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">而不是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">下面列出了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">的不同点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">可以包含基本类型和对象类型，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">只能包含对象类型。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">大小是固定的，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">的大小是动态变化的。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了更多的方法和特性，比如：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">addAll()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">removeAll()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">iterator()</span></font><font face="宋体" size="5"><span style="font-size:18pt">等等。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">27.ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">都实现了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口，他们有以下的不同点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">是基于索引的数据接口，它的底层是数组。它可以以</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(1)</span></font><font face="宋体" size="5"><span style="font-size:18pt">时间复杂度对元素进行随机访问。与此对应，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">相对于</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">比</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">更占内存，因为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">也可以参考</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList vs. LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">28.Comparable</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口是干什么的？列出它们的区别。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了只包含一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">compareTo()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Comparable</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口。这个方法可以个给两个对象排序。具体来说，它返回负数，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">0</span></font><font face="宋体" size="5"><span style="font-size:18pt">，正数来表明输入对象小于，等于，大于已经存在的对象。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了包含</span></font><font face="Verdana" size="5"><span style="font-size:18pt">compare()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">两个方法的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">compare()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法用来给两个输入参数排序，返回负数，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">0</span></font><font face="宋体" size="5"><span style="font-size:18pt">，正数表明第一个参数是小于，等于，大于第二个参数。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法需要一个对象作为参数，它用来决定输入参数是否和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">相等。只有当输入参数也是一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">并且输入参数和当前</span></font><font face="Verdana" size="5"><span style="font-size:18pt">comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的排序结果是相同的时候，这个方法才返回</span></font><font face="Verdana" size="5"><span style="font-size:18pt">true</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">29.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">优先级队列</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Priority Queue)</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">PriorityQueue</span></font><font face="宋体" size="5"><span style="font-size:18pt">是一个基于优先级堆的无界队列，它的元素是按照自然顺序</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(natural order)</span></font><font face="宋体" size="5"><span style="font-size:18pt">排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">PriorityQueue</span></font><font face="宋体" size="5"><span style="font-size:18pt">不允许</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">PriorityQueue</span></font><font face="宋体" size="5"><span style="font-size:18pt">不是线程安全的，入队和出队的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(log(n))</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">30.</span></font><font face="宋体" size="5"><span style="font-size:18pt">你了解大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(big-O notation)</span></font><font face="宋体" size="5"><span style="font-size:18pt">么？你能给出不同数据结构的例子么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:4.22mm;min-height: 13pt;"><font face="宋体" size="5"><span style="font-size:18pt">大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 14pt;"><font face="宋体" size="5"><span style="font-size:18pt">大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号基于时间，内存和性能来选择最好的实现。大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号可以对大量数据的性能给出一个很好的说明。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">31.</span></font><font face="宋体" size="5"><span style="font-size:18pt">如何权衡是使用无序的数组还是有序的数组？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">有序数组最大的好处在于查找的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(log n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，而无序数组是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。有序数组的缺点是插入操作的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(1)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">32.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类框架的最佳实践有哪些？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">而不是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">值或者是扩容。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ClassCastException</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDK</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供的不变类</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(immutable class)</span></font><font face="宋体" size="5"><span style="font-size:18pt">作为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Map</span></font><font face="宋体" size="5"><span style="font-size:18pt">的键可以避免为我们自己的类实现</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">编程的时候接口优于实现。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">底层的集合实际上是空的情况下，返回长度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">0</span></font><font face="宋体" size="5"><span style="font-size:18pt">的集合或者是数组，不要返回</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">33.Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口的区别有哪些？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">速度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">2</span></font><font face="宋体" size="5"><span style="font-size:18pt">倍，同时占用更少的内存。但是，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">远远比</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">安全，因为其他线程不能够修改正在被</span></font><font face="Verdana" size="5"><span style="font-size:18pt">iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">遍历的集合里面的对象。同时，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">允许调用者删除底层集合里面的元素，这对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">来说是不可能的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">34.HashSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">TreeSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">HashSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">是由一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">表来实现的，因此，它的元素是无序的。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">add()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">remove()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">contains()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(1)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><div><font face="宋体" size="5"><span style="font-size:18pt">另一方面，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">TreeSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">是由一个树形的结构来实现的，它里面的元素是有序的。因此，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">add()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">remove()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">contains()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(logn)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></div></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16px;">59. Collection 框架中实现比较要实现什么接口</span></div><div><span style="font-size: 16px;">comparable/comparator</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">60. ArrayList 和 Vector 的区别</span></div><div><span style="font-size: 16px;">答：</span></div><div><span style="font-size: 16px;">这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以</span> <span style="font-size: 16px;">按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元</span> <span style="font-size: 16px;">素（本来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对比方式，更有利于说明问题）。</span></div><div><span style="font-size: 16px;">接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面：.</span></div><div><span style="font-size: 16px;">1） 同步性：</span></div><div><span style="font-size: 16px;">Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用</span></div><div><span style="font-size: 16px;">ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</span></div><div><span style="font-size: 16px;">备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住 Vector 与 Hashtable 是旧的，是 java 一诞生就提供了的，它们是线程安全的，ArrayList</span> <span style="font-size: 16px;">与 HashMap 是 java2 时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。</span></div><div><span style="font-size: 16px;">2） 数据增长：</span></div><div><span style="font-size: 16px;">ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加</span> <span style="font-size: 16px;">一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档</span> <span style="font-size: 16px;">中没有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空</span> <span style="font-size: 16px;">间的方法。</span></div><div><span style="font-size: 16px;">总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">61. HashMap 和 Hashtable 的区别</span></div><div><span style="font-size: 16px;">（条理上还需要整理，也是先说相同点，再说不同点）</span></div><div><span style="font-size: 16px;">HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），他们都完成了 Map 接口，主要区别在于 HashMap 允许空（null）键值（key）,由于非线程安全，在只有一个线程</span> <span style="font-size: 16px;">访问的情况下，效率要高于 Hashtable。</span></div><div><span style="font-size: 16px;">HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</span></div><div><span style="font-size: 16px;">HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsvalue 和 containsKey。因为 contains 方法容易让人引起误解。</span></div><div><span style="font-size: 16px;">Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</span></div><div><span style="font-size: 16px;">最大的不同是，Hashtable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同</span> <span style="font-size: 16px;">步。</span></div><div><span style="font-size: 16px;">Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</span></div><div><span style="font-size: 16px;">就 HashMap 与 HashTable 主要从三方面来说。</span></div><div><span style="font-size: 16px;">1、 历史原因：Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口的一个实现</span></div><div><span style="font-size: 16px;">2、 同步性：Hashtable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，不是同步的</span></div><div><span style="font-size: 16px;">3、 值：只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">62. List 和 Map 区别?</span></div><div><span style="font-size: 16px;">一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合， List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其键是不能重复的，</span> <span style="font-size: 16px;">它的值是可以有重复的。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">63. List, Set, Map 是否继承自 Collection 接口?</span></div><div><span style="font-size: 16px;">List，Set 是，Map 不是</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">64. List、Map、Set 三个接口，存取元素时，各有什么特点？</span></div><div><span style="font-size: 16px;">这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。</span></div><div><span style="font-size: 16px;">如果你明白，但表述不清楚，在别人那里则等同于不明白。</span></div><div><span style="font-size: 16px;">首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注</span> <span style="font-size: 16px;">意，不是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集</span> <span style="font-size: 16px;">合的 add 方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法</span> <span style="font-size: 16px;">无法加入该元素，返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，再逐一遍历各个元素。</span></div><div><span style="font-size: 16px;">List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用 add(Obje)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来</span> <span style="font-size: 16px;">后到的顺序排序。有时候，也可以插队，即调用 add(intindex,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这</span> <span style="font-size: 16px;">个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指</span> <span style="font-size: 16px;">向了这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元素之外，还可以调用 get(index i)来明确说明取第几个。</span></div><div><span style="font-size: 16px;">Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对 key/value，不能存储重复的 key，这个重复的规则</span> <span style="font-size: 16px;">也是按 equals 比较相等。取则可以根据 key 获得相应的 value，即 get(Object key)返回值为 key 所对应的 value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value</span> <span style="font-size: 16px;">的结合，还可以获得 key 和 value 组合成的 Map.Entry 对象的集合。</span></div><div><span style="font-size: 16px;">List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存 key-value 值，value 可多值。</span></div><div><span style="font-size: 16px;">HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行存储。例如，&quot;abc&quot;---&gt;78， &quot;def&quot; ---&gt; 62，&quot;xyz&quot; ---&gt; 65 在 hashSet 中的存储</span> <span style="font-size: 16px;">顺序不是 62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet 按插入的顺序存储，那</span> <span style="font-size: 16px;">被存储对象的 hashcode 方法还有什么作用呢？学员想想!hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法是否相等。new 两个 Student</span> <span style="font-size: 16px;">插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals 方法后再看 size。</span></div><div><span style="font-size: 16px;">同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往 HashSet 中却加不了多次的。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">65. 说出 ArrayList,Vector, LinkedList 的存储性能和特性</span></div><div><span style="font-size: 16px;">ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等</span> <span style="font-size: 16px;">内存操作，所以索引数据快而插入数据慢， Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据</span> <span style="font-size: 16px;">需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</span></div><div><span style="font-size: 16px;">LinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得 LinkedList 可以被当作堆栈和队列来使用。</span></div><div><br/></div><div><span style="font-size: 16px;">66. 去掉一个 Vector 集合中重复的元素 Vector newVector = new Vector();</span></div><div><img src="collection_files/Image [1].png" type="image/png"/></div><div><span style="font-size: 16px;">还有一种简单的方式，HashSet set = new HashSet(vector);</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">67. Collection 和 Collections 的区别。</span></div><div><span style="font-size: 16px;">Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List；</span></div><div><span style="font-size: 16px;">Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">68. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是 equals()? 它们有何区别?</span></div><div><span style="font-size: 16px;">Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。</span></div><div><span style="font-size: 16px;">equals()和==方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">69. 你所知道的集合类都有哪些？主要方法？</span></div><div><span style="font-size: 16px;">最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索</span> <span style="font-size: 16px;">引访问元素的情形。</span></div><div><span style="font-size: 16px;">Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作&quot;键&quot;和&quot;值&quot;），其中每个键映射到一个值。</span></div><div><span style="font-size: 16px;">ArrayList/Vector → List</span></div><div><span style="font-size: 16px;">→ Collection</span></div><div><span style="font-size: 16px;">HashSet/TreeSet → Set</span></div><div><span style="font-size: 16px;">Properties → HashTable</span></div><div><span style="font-size: 16px;">→ Map</span></div><div><span style="font-size: 16px;">Treemap/HashMap</span></div><div><span style="font-size: 16px;">我记的不是方法名，而是思想，我知道它们都有增删改查的方法，但这些方法的具体名称，我记得不是很清楚，对于 set，大概的方法是 add，remove，contains；对于 map，</span> <span style="font-size: 16px;">大概的方法就是 put，remove，contains 等，因为，我只要在 eclispe 下按点操作符，很自然的这些方法就出来了。我记住的一些思想就是 List 类会有 get(int index)这样的方法，</span> <span style="font-size: 16px;">因为它可以按顺序取元素，而 set 类中没有 get(int index)这样的方法。List 和 set 都可以迭代出所有元素，迭代时先要得到一个 iterator 对象，所以，set 和 list 类都有一个 iterator</span> <span style="font-size: 16px;">方法，用于返回那个 iterator 对象。map 可以返回三个集合，一个是返回所有的 key 的集合，另外一个返回的是所有 value 的集合，再一个返回的 key 和 value 组合成的 EntrySet</span> <span style="font-size: 16px;">对象的集合，map 也有 get 方法，参数是 key，返回值是 key 对应的 value。</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;">70. 两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?</span></div><div><span style="font-size: 16px;">对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode 值就必须相等。</span></div><div><span style="font-size: 16px;">如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode 不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没</span> <span style="font-size: 16px;">有理由不实现，通常都会去实现的。</span></div><div><br/></div><div><span style="font-size: 16px;">71. TreeSet 里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的 compareTo 方法，还是使用的子类的 compareTo 方法，</span></div><div><span style="font-size: 16px;">还是抛异常！</span></div><div><span style="font-size: 16px;">（应该是没有针对问题的确切的答案，当前的 add 方法放入的是哪个对象，就调用哪个对象的 compareTo 方法，至于这个 compareTo 方法怎么做，就看当前这个对象的类中是如何</span></div><div><span style="font-size: 16px;">编写这个方法的）实验代码：</span></div><div><img src="collection_files/Image [2].png" type="image/png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 