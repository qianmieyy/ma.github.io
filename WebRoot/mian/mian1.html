<html>
<head>
  <title>面试题1</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1512"/>
<h1>面试题1</h1>

<div>
<span><div>1，线程的创建的方式：</div><div>答：1,继承Thread(注意，此类其实也是实现了Runnable接口的)，2,实现Runnable接口</div><div><br/></div><div>2，1. 下面哪些是Thread类的方法（）</div><div>A start()       B run()       C exit()       D getPriority()</div><div><br/></div><div>答案：ABD</div><div>start();当前线程处理就绪状态，但并未开始。等CPU给你分配时间片</div><div>run():当前线程要执行的任务，写在这个方法中。</div><div>getPriority(),线程的优先级，1-10;</div><div><br/></div><div>3, 下面关于java.lang.Exception类的说法正确的是（）</div><div><br/></div><div>A 继承自Throwable      B Serialable      CD 不记得，反正不正确</div><div><br/></div><div>答案：A</div><div><br/></div><div>4, 异常处理中，都有哪些关键字？</div><div>答：5</div><div><br/></div><div>5，下面程序的运行结果是（）</div><div><br/></div><div>String str1 = &quot;hello&quot;;</div><div>String str2 = &quot;he&quot; + new String(&quot;llo&quot;);</div><div>System.err.println(str1 == str2);</div><div>答案：false</div><div><br/></div><div>6， 下列说法正确的有（）</div><div><br/></div><div>A． class中的constructor不可省略</div><div><br/></div><div>B． constructor必须与class同名，但方法不能与class同名</div><div><br/></div><div>C． constructor在一个对象被new时执行</div><div><br/></div><div>D．一个class只能定义一个constructor</div><div><br/></div><div>答案：C</div><div><br/></div><div>解析：这里可能会有误区，其实普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。</div><div><br/></div><div>7，数组是否有默认值？</div><div>有，字符串为null,整数为0</div><div><br/></div><div>8,如果定义的类的名称前加上了public ，问这个类名是否必须和这个类的文件名相同？</div><div>答：是。相反，则可以不相同。</div><div><br/></div><div>9，下面程序的运行结果：（）</div><div><br/></div><div>复制代码</div><div>    public static void main(String args[]) {</div><div><br/></div><div>        Thread t = new Thread() {</div><div><br/></div><div>            public void run() {</div><div>                pong();</div><div>            }</div><div>        };</div><div><br/></div><div>        t.run();</div><div>        System.out.print(&quot;ping&quot;);</div><div><br/></div><div>    }</div><div><br/></div><div>    static void pong() {</div><div><br/></div><div>        System.out.print(&quot;pong&quot;);</div><div><br/></div><div>    }</div><div><br/></div><div>复制代码</div><div>A pingpong        B pongping       C pingpong和pongping都有可能       D 都不输出</div><div><br/></div><div>答案：B</div><div><br/></div><div>解析：这里考的是Thread类中start()和run()方法的区别了。start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程，进而调用run()方法来执行任务，而单独的调用run()就跟调用普通方法是一样的，已经失去线程的特性了。因此在启动一个线程的时候一定要使用start()而不是run()。</div><div><br/></div><div>--------------------------------------</div><div><br/></div><div>10，下列属于关系型数据库的是（）</div><div><br/></div><div>A. Oracle    B MySql    C IMS     D MongoDB</div><div><br/></div><div>答案：AB</div><div><br/></div><div>解答：IMS（Information Management System ）数据库是IBM公司开发的两种数据库类型之一;</div><div><br/></div><div>一种是关系数据库，典型代表产品：DB2；</div><div><br/></div><div>另一种则是层次数据库，代表产品：IMS层次数据库。</div><div><br/></div><div>非关系型数据库有MongoDB、memcachedb、Redis等。</div><div><br/></div><div><br/></div><div>11，什么是关系型数据库？</div><div>所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织</div><div><br/></div><div>12，什么是非关系型数据库？</div><div>不满足上面11题的。</div><div><br/></div><div><span style="color: rgb(235, 0, 115);"><b>13，nosql.</b></span></div><div><span style="color: rgb(235, 0, 115);"><b>答：1，键值对(redis..)，2，列模型(HBase..),3,文档模型(mongoDB..)</b></span></div><div><br/></div><div>14,什么是GC?</div><div>垃圾回收(GC)机制</div><div><br/></div><div><br/></div><div>15,GC线程是否为守护线程？（）</div><div><br/></div><div>答案：是</div><div><br/></div><div>解析：线程分为守护线程和非守护线程（即用户线程）。</div><div><br/></div><div>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。</div><div>守护线程最典型的应用就是 GC (垃圾回收器)</div><div><br/></div><div><span style="color: rgb(255, 0, 0);"><b>16，接口就是纯的抽象类。接口中的方法或常量，隐含了哪些关键字？抽象类不能new,接口不能new.</b></span></div><div><span style="color: rgb(255, 0, 0);"><b><br/></b></span></div><div><span style="color: rgb(255, 0, 0);"><b>17，抽象类，类前面有abstract,方法可以有或没有abstract,方法有abstract则不能有代码体</b></span></div><div><br/></div><div>18，下列说法正确的是（）</div><div><br/></div><div>A LinkedList实现自List</div><div><br/></div><div>B AbstractSet继承自Set</div><div><br/></div><div>C HashSet继承自AbstractSet</div><div><br/></div><div>D WeakMap继承自HashMap</div><div><br/></div><div>答案：AC</div><div><br/></div><div>-----------------------</div><div><br/></div><div>19， 存在使i + 1 &lt; i的数吗（）</div><div><br/></div><div>答案：存在</div><div><br/></div><div>解析：如果i为int型，那么当i为int能表示的最大整数时，i+1就溢出变成负数了，此时不就&lt;i了吗。</div><div><br/></div><div>20,0.6332的数据类型是（）</div><div><br/></div><div>A float     B double     C Float      D Double</div><div><br/></div><div>答案：B</div><div><br/></div><div>解析：默认为double型，如果为float型需要加上f显示说明，即0.6332f</div><div><br/></div><div>21,下面哪个流类属于面向字符的输入流(  )</div><div><br/></div><div>A  BufferedWriter           B  FileInputStream          C  ObjectInputStream          D  InputStreamReader</div><div><br/></div><div> 答案：D</div><div><br/></div><div>22,Java接口的修饰符可以为（）</div><div><br/></div><div>A private     B protected     C final       D abstract</div><div><br/></div><div>答案：CD</div><div><br/></div><div>------</div><div>23,接口默认修饰关键字：</div><div><br/></div><div>接口的方法默认是public abstract；</div><div><br/></div><div>接口中不可以定义变量即只能定义常量(加上final修饰就会变成常量)。</div><div><br/></div><div>所以接口的属性默认是public static final 常量，且必须赋初值。</div><div><br/></div><div>注意：final和abstract不能同时出现。</div><div><br/></div><div><br/></div><div>------</div><div>24，不通过构造函数也能创建对象吗（）</div><div><br/></div><div>A 是     B 否</div><div><br/></div><div>答案：A</div><div><br/></div><div>解析：Java创建对象的几种方式（重要）：</div><div><br/></div><div>(1) 用new语句创建对象，这是最常见的创建对象的方法。</div><div>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</div><div>(3) 调用对象的clone()方法。</div><div>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</div><div><br/></div><div>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。</div><div><br/></div><div><br/></div><div>-------</div><div>25，ArrayList list = new ArrayList(20);中的list扩充几次（）</div><div><br/></div><div>A 0     B 1     C 2      D 3</div><div><br/></div><div>答案：A</div><div><br/></div><div><br/></div><div>-------</div><div><br/></div><div>26，下面哪些是对称加密算法（）</div><div><br/></div><div>A DES   B AES   C DSA   D RSA</div><div><br/></div><div>答案：AB</div><div><br/></div><div>解析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES</div><div><br/></div><div>常用的非对称加密算法有：RSA、DSA、ECC</div><div><br/></div><div>使用单向散列函数的加密算法：MD5、SHA</div><div><br/></div><div>----</div><div><br/></div><div>27，新建一个流对象，下面哪个选项的代码是错误的？（）</div><div><br/></div><div>A）new BufferedWriter(new FileWriter(&quot;a.txt&quot;));</div><div><br/></div><div>B）new BufferedReader(new FileInputStream(&quot;a.dat&quot;));</div><div><br/></div><div>C）new GZIPOutputStream(new FileOutputStream(&quot;a.zip&quot;));</div><div><br/></div><div>D）new ObjectInputStream(new FileInputStream(&quot;a.dat&quot;));</div><div><br/></div><div>答案：B</div><div><br/></div><div>28，下面程序能正常运行吗（）</div><div>public class Test {</div><div><br/></div><div>    public static void haha(){</div><div>        System.out.println(&quot;haha&quot;);</div><div>    }</div><div>    public static void main(String[] args) {</div><div>        ((Test)null).haha();</div><div>    }</div><div><br/></div><div>}</div><div>    /*</div><div>    (Test)null相当于 Test t=null;</div><div>    ------</div><div>    如果haha()方法为静态的,</div><div>    Test t=null;</div><div>    t.haha();</div><div>    相当于</div><div>    Test.haha();是可以调用的。</div><div>    ----------</div><div>    所在下面这个</div><div>    ((Test)null).haha();</div><div>    相当于Test.haha();是可以运行调用的。</div><div>    */</div><div>======</div><div>答案：能正常运行</div><div><br/></div><div>解析：输出为haha，因为null值可以强制转换为任何java类类型,(String)null也是合法的。</div><div>但null强制转换后是无效对象，其返回值还是为null，</div><div>而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。</div><div>反过来，没有static修饰就只能用对象进行访问，</div><div>使用null调用对象肯定会报空指针错了。这里和C++很类似</div><div><br/></div><div>29,代码执行顺序：</div><div>class HelloA {</div><div><br/></div><div>    public HelloA() {</div><div>        System.out.println(&quot;HelloA&quot;);</div><div>    }</div><div><br/></div><div>    { System.out.println(&quot;I'm A class&quot;); }</div><div><br/></div><div>    static { System.out.println(&quot;static A&quot;); }</div><div><br/></div><div>}</div><div><br/></div><div>public class HelloB extends HelloA {</div><div>    public HelloB() {</div><div>        System.out.println(&quot;HelloB&quot;);</div><div>    }</div><div><br/></div><div>    { System.out.println(&quot;I'm B class&quot;); }</div><div><br/></div><div>    static { System.out.println(&quot;static B&quot;); }</div><div><br/></div><div>    public static void main(String[] args) {</div><div>        new HelloB();</div><div>    }</div><div>}</div><div><br/></div><div>结果：</div><div>static A</div><div>static B</div><div>I'm A class</div><div>HelloA</div><div>I'm B class</div><div>HelloB</div><div><br/></div><div><br/></div></span>
</div></body></html> 