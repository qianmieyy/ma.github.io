<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1518"/>

<div>
<span><div><div><br/></div><div><b>三范式</b></div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><b>第一范式（</b><b>1NF</b><b>）无重复的列</b>　　所谓第一范式（1NF）是<b>指数据库表的每一列都是不可分割的基本数据</b> <b>项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</b>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。<br/><b>1NF</b><b>的定义为：符合</b><b>1NF</b><b>的关系中的每个属性都不可再分</b>下表所示情况，便不符合1NF的要求：<img src="shiwu_files/Image.png" type="image/png" alt="graphic"/><br/><div><br/></div>
说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br/><b>第二范式（</b><b>2NF</b><b>）属性完全依赖于主键</b> 　　第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。<br/><div><br/></div>
        第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。<br/><b>简而言之，第二范式就是属性完全依赖于主键。</b><b><br/></b><b>第三范式（</b><b>3NF</b><b>）</b> 　　满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，<b>第三范式（</b><b>3NF</b><b>）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息</b>。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。<br/><b>简而言之，第三范式就是属性不依赖于其它非主属性</b><b>。</b><b> </b><b>也就是说，</b> <b>如果存在非主属性对于码的传递函数依赖，则不符合</b><b>3NF</b><b>的要求。</b><br/></div></td></tr></table><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><b>如何理解超键、候选键、主键、外键的含义？</b><br/><ul><li>超键：在关系模式中，能唯一标识元组的属性集称为超键（有多余的属性）</li></ul><ul><li>候选键：在关系模式中，能唯一标识元组并且不含多余属性集称为候选键（不能有多余的属性）</li></ul><ul><li>主键：在关系模式中，由若干个候选键中指定一个作为关键字，该关键字称为主键</li></ul><ul><li>外键：如果在关系模式R1中的某属性集不是R1的候选键，而是关系模式R2的候选键，则该属性集对R1而言是外键（这是对于R1而言而不是对R2的）
<div><br/></div><br/>
例如：学生（学号，姓名，性别，专业号，年龄）
<div><br/></div><br/>
（学号，姓名）是超键，而不是候选键，学号是候选键，同时也是主键</li></ul><br/><br/><ul><li>主属性：候选码中的诸属性称为主属性</li></ul><ul><li>非主属性：不包含在任意候选码中的属性称为非主属性
<div><br/></div><br/>
例如：成绩（学号，姓名，课程号，成绩）注：学生无同名
<div><br/></div><br/>
候选键：（学号，课程号），（姓名，课程号）
<div><br/></div><br/>
主属性：学号，姓名，课程号
<div><br/></div><br/>
非主属性：成绩</li></ul><br/><br/><br/><br/><br/>
如何区分超键，候选键，主键？<br/><div><br/></div>
超键中可能有无关属性，而主键和候选键中属性都是必要的属性。<br/><div><br/></div>
主键和候选键的区别在于主键被数据库设计者选择的，事实上也是候选键。<br/><div><br/></div>
例如：有三个总统候选人A,B,C，但A被选中当总统，所以A是主键<br/></div></td></tr></table><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><b>常见面试题整理</b><b>--</b><b>数据库篇（每位开发者必备）</b><br/>
那么常见的数据库面试题有哪些呢？<br/><img src="shiwu_files/Image [1].png" type="image/png" alt="graphic"/>（一）什么是存储过程？有哪些优缺点？存储过程是一些预编译的SQL语句。更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。
<ul><li>存储过程是一个预编译的代码块，执行效率比较高</li></ul><ul><li>一个存储过程替代大量T_SQL语句，可以降低网络通信量，提高通信速率</li></ul><ul><li>可以一定程度上确保数据安全</li></ul>
（二）索引是什么？有什么作用以及优缺点？索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。<b>MySQL</b>数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引
<ul><li>索引加快数据库的检索速度</li></ul><ul><li>索引降低了插入、删除、修改等维护任务的速度</li></ul><ul><li>唯一索引可以确保每一行数据的唯一性</li></ul><ul><li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li></ul><ul><li>索引需要占物理和数据空间</li></ul><br/>
（三）什么是事务？事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。（四）数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。
<ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li></ul><ul><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li></ul>
（五） 使用索引查询一定能提高查询的性能吗？为什么通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:
<ul><li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li></ul><ul><li>基于非唯一性索引的检索</li></ul>
（六）简单说一说<b>drop</b><b>、</b><b>delete</b>与<b>truncate</b>的区别SQL中的<b>drop</b><b>、</b><b>delete</b><b>、</b><b>truncate</b>都表示删除，但是三者有一些差别
<ul><li><b>delete</b><b>和</b><b>truncate</b>只删除表的数据不删除表的结构</li></ul><ul><li>速度,一般来说:<b> drop&gt; truncate &gt;delete</b></li></ul><ul><li><b>delete</b>语句是dml,这个操作会放到<b>rollback segement</b>中,事务提交之后才生效;
<div><br/></div><br/>
如果有相应的<b>trigger</b>,执行的时候将被触发. <b>truncate,drop</b>是ddl, 操作立即生效,原数据不放到r<b>ollback segment</b>中,不能回滚. 操作不触发<b>trigger</b>.</li></ul>
（七）<b>drop</b><b>、</b><b>delete</b>与<b>truncate</b>分别在什么场景之下使用？
<ul><li>不再需要一张表的时候，用<b>drop</b></li></ul><ul><li>想删除部分数据行时候，用<b>delete</b>，并且带上where子句</li></ul><ul><li>保留表而删除所有数据的时候用<b>truncate</b></li></ul>
（八） 超键、候选键、主键、外键分别是什么？超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。候选键：是最小超键，即没有冗余元素的超键。主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。外键：在一个表中存在的另一个表的主键称此表的外键。（九）什么是视图？以及视图的使用场景有哪些？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
<ul><li>只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li></ul><ul><li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</li></ul>
（十）说一说三个范式。第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在&quot;A → B → C&quot;的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y<br/></div></td></tr></table><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><b>数据库事务的四大特性以及事务的隔离级别</b><br/>
本篇讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。　　如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：<b>⑴</b> <b>原子性（</b><b>Atomicity</b><b>）</b>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。<br/><b>⑵</b> <b>一致性（</b><b>Consistency</b><b>）</b>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br/>
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。<b>⑶</b> <b>隔离性（</b><b>Isolation</b><b>）</b>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br/>
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。<b>⑷</b> <b>持久性（</b><b>Durability</b><b>）</b>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br/>
　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。<br/>
　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：<b>1</b><b>，脏读</b>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。<br/>
　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下    update account set money=money+<b>100</b> where name=’B’;  (此时A通知B)    update account set money=money - <b>100</b> where name=’A’;　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。<b>2</b><b>，不可重复读</b>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。<br/>
　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……<b>3</b><b>，虚读</b><b>(</b><b>幻读</b><b>)</b>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br/>
　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。<br/>
　　现在来看看MySQL数据库为我们提供的四种隔离级别：　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。　　③ Read committed (读已提交)：可避免脏读的发生。　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。<br/>
　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。　　在MySQL数据库中查看当前事务的隔离级别：    select <b>@@tx_isolation</b>;　　在MySQL数据库中设置事务的隔离 级别：    set  [glogal | session]  transaction isolation level 隔离级别名称;    set tx_isolation=’隔离级别名称;’例1：查看当前事务的隔离级别：<br/><img src="shiwu_files/Image [2].png" type="image/png" alt="graphic"/>例2：将事务的隔离级别设置为Read uncommitted级别：<br/><img src="shiwu_files/Image [3].png" type="image/png" alt="graphic"/>或：<br/><img src="shiwu_files/Image [4].png" type="image/png" alt="graphic"/>记住：设置数据库的隔离级别一定要是在开启事务之前！　　如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：<br/><img src="shiwu_files/Image [5].png" type="image/png" alt="graphic"/>在JDBC中设置隔离级别的部分代码：<br/><img src="shiwu_files/Image [6].png" type="image/png" alt="graphic"/>　　后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。<br/></div></td></tr></table></div></span>
</div></body></html> 