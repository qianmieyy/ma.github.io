<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1626"/>

<div>
<span><div>1. 什么是设计模式，设计模式的作用。</div><div>设计模式是一套被反复使用的、多数人知晓、经过分类编目的优秀代码设计经验的总结。特定环境下</div><div>特定问题的处理方法。</div><ol><li>重用设计和代码 重用设计比重用代码更有意义，自动带来代码重用</li><li>提高扩展性 大量使用面向接口编程，预留扩展插槽，新的功能或特性很容易加入到系统中来</li><li>提高灵活性 通过组合提高灵活性，可允许代码修改平稳发生，对一处修改不会波及到其他模块</li><li>提高开发效率 正确使用设计模式，可以节省大量的时间</li></ol><div><br/></div><div><br/></div><div>2. 面向对象设计原则有哪些</div><div>面向对象设计原则是面向对象设计的基石，面向对象设计质量的依据和保障，设计模式是面向对象设</div><div>计原则的经典应用</div><div>1) 单一职责原则 SRP</div><div>2) 开闭原则 OCP</div><div>3) 里氏替代原则 LSP</div><div>4) 依赖注入原则 DIP</div><div>5) 接口分离原则 ISP</div><div>6) 迪米特原则 LOD</div><div>7) 组合 /聚合复用原则 CARP</div><div>开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他设计原则都可以看作是开闭</div><div>原则的实现手段或方法</div><div><br/></div><div><br/></div><div>3. 23 种经典设计模式都有哪些，如何分类。</div><div><img src="design_files/Image.png" type="image/png"/></div><div><img src="design_files/Image [1].png" type="image/png"/></div><div><br/></div><div>4. 写出简单工厂模式的示例代码</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public class SimpleFactory {</div><div>public static Product createProduct(String pname){</div><div>Product product= null ;</div><div>if (&quot;p1&quot;.equals(pname)){</div><div>product =  new Product1();</div><div>} else if (&quot;p2&quot;.equals(pname)){</div><div>product =  new Product2();</div><div>} else if (&quot;pn&quot;.equals(pname)){</div><div>product =  new ProductN();</div><div>}</div><div>return product;</div><div>}</div><div>}</div></div><div><br/></div><div>基本原理：由一个工厂类根据传入的参数（一般是字符串参数），动态决定应该创建哪一个产</div><div>品子类（这些产品子类继承自同一个父类或接口）的实例，并以父类形式返回</div><div>优点：客户端不负责对象的创建，而是由专门的工厂类完成；客户端只负责对象的调用，实现了创建</div><div>和调用的分离，降低了客户端代码的难度；</div><div>缺点：如果增加和减少产品子类，需要修改简单工厂类，违背了开闭原则；如果产品子类过多，</div><div>会导致工厂类非常的庞大，违反了高内聚原则，不利于后期维护</div><div>5. 写出单例模式的示例代码</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>/**</div><div>* 饿汉式的单例模式</div><div>* 在类加载的时候创建单例实例，而不是等到第一次请求实例的时候的时候创建</div><div>* 1 、私有 的无参数构造方法 Singleton() ，避免外部创建实例</div><div>* 2 、私有静态属性 instance</div><div>* 3 、公有静态方法 getInstance()</div><div>*/</div><div>public class Singleton {</div><div>private static Singleton  instance =  new Singleton();</div><div>private Singleton(){  }</div><div>public static Singleton getInstance(){</div><div>return instance ;</div><div>}</div><div>}</div><div>/**</div><div>* 懒汉式的单例模式</div><div>* 在类加载的时候不创建单例实例，只有在第一次请求实例的时候的时候创建</div><div>*/</div><div>public class Singleton {</div><div>private static Singleton  instance ;</div><div>private Singleton(){  }</div><div>/**</div><div>* 多线程情况的单例模式，避免创建多个对象</div><div>*/</div><div>public static Singleton getInstance(){</div><div>if ( instance == null ){// 避免每次加锁，只有第一次没有创建对象时才加锁</div><div>synchronized (Singleton. class ){// 加锁，只允许一个线程进入</div><div>if ( instance ==null ){ // 只创建一次对象</div><div>instance =  new Singleton();</div><div>}</div><div>}</div><div>}</div><div>return instance ;</div><div>}</div><div>}</div></div><div><br/></div><div>6. 请对你所熟悉的一个设计模式进行介绍</div><div>分析：建议挑选有一定技术难度，并且在实际开发中应用较多的设计模式。可以挑选装饰模式和动态</div><div>代理模式。此处挑选动态代理设计模式。</div><div>讲解思路：生活案例引入、技术讲解、优缺点分析、典型应用。</div><div>1、生活案例引入： 送生日蛋糕：</div><div>MM们要过生日了，怎么也得表示下吧。最起码先送个蛋糕。蛋糕多种多样了。巧克力，冰淇淋，</div><div>奶油等等。 这都是基本的了， 再加点额外的装饰， 如蛋糕里放点花、 放贺卡、 放点干果吃着更香等等。</div><div>分析：</div><div>方案 1: 如果采用继承会造成大量的蛋糕子类</div><div>方案 2、蛋糕作为主体，花，贺卡，果仁等是装饰者，需要时加到蛋糕上。要啥我就加啥。</div><div>1、 技术讲解</div><div>装饰模式（别名 Wrapper）是在不必改变原类文件和使用继承的情况下，动态的扩展一个</div><div>对象的功能。它通过创建一个包装对象，也就是装饰来包裹真实对象 ，提供了比继承更具弹性</div><div>的代替方案。</div><div>装饰模式一般涉及到的角色</div><div>抽象构建角色 (Component): 给出一个抽象的接口， 以规范准备接受附加责任的对象。</div><div>具体的构建角色 (ConcreteComponent) ：定义一个将要接受附加责任的类。</div><div>抽象的装饰角色 (Decorator): 持有一个抽象构建 (Component) 角色的引用，并定义</div><div>一个与抽象构件一致的接口。</div><div>具体的装饰角色 (ConcreteDecorator): 负责给构建对象“贴上”附加的责任。</div><div><img src="design_files/Image [2].png" type="image/png"/></div><div><br/></div><div>3、优缺点分析</div><div>优点</div><div>Decorator 模式与继承关系的目的都是要扩展对象的功能， 但是 Decorato 更多的灵活</div><div>性。</div><div>把类中的装饰功能从类中搬移出去，这样可以简化原有的类。有效地把类的核心功能</div><div>和装饰功能区分开了。</div><div>通过使用不同的具体装饰类以及这些装饰类的排列组合， 可创造出很多不同行为的组</div><div>合。</div><div>缺点</div><div>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</div><div>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</div><div>符合的设计原则：</div><div>多用组合，少用继承。利用继承设计子类的行为是在编译时静态决定的，且所有的子</div><div>类都会继承到相同的行为。如能够利用组合扩展对象的行为，就可在运行时动态进</div><div>行扩展。</div><div>类应设计的对扩展开放，对修改关闭。</div><div><br/></div><div><br/></div><div>4、典型应用</div><div>java IO 中需要完成对不同输入输出源的操作，如果单纯的使用继承这一方式，无疑需要很多的</div><div>类。比如说，我们操作文件需要一个类，实现文件的字节读取需要一个类，实现文件的字符读取又需</div><div>要一个类 .... 一次类推每个特定的操作都需要一个特定的类。 这无疑会导致大量的 IO 继承类的出现。</div><div>显然对于编程是很不利的。</div><div>而是用装饰模式则可以很好的解决这一问题，在装饰模式中：节点流（如 FileInputStream ）直</div><div>接与输入源交互，之后通过过滤流（ FilterInputStream ）进行装饰，这样获得的 io 对象便具有某几</div><div>个的功能，很好的拓展了 IO 的功能。</div><div><img src="design_files/Image [3].png" type="image/png"/></div><div><br/></div><div><br/></div></span>
</div></body></html> 