<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1602"/>

<div>
<span><div><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">11.</span></font><font face="宋体" size="5"><span style="font-size:18pt">进程和线程的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">12.</span></font><font face="宋体" size="5"><span style="font-size:18pt">创建线程有几种不同的方式？你喜欢哪一种？为什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">有三种方式可以用来创建线程：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">继承</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Thread</span></font><font face="宋体" size="5"><span style="font-size:18pt">类</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">实现</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Runnable</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">应用程序可以使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Executor</span></font><font face="宋体" size="5"><span style="font-size:18pt">框架来创建线程池</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">实现</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Runnable</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口这种方式更受欢迎，因为这不需要继承</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Thread</span></font><font face="宋体" size="5"><span style="font-size:18pt">类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">13.</span></font><font face="宋体" size="5"><span style="font-size:18pt">概括的解释下线程的几种可用状态。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">线程在执行过程中，可以处于下面几种状态：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">就绪</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Runnable):</span></font><font face="宋体" size="5"><span style="font-size:18pt">线程准备运行，不一定立马就能开始执行。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">运行中</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Running)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：进程正在执行线程的代码。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">等待中</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Waiting):</span></font><font face="宋体" size="5"><span style="font-size:18pt">线程处于阻塞的状态，等待外部的处理结束。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">睡眠中</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Sleeping)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：线程被强制睡眠。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">I/O</span></font><font face="宋体" size="5"><span style="font-size:18pt">阻塞</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Blocked on I/O)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：等待</span></font><font face="Verdana" size="5"><span style="font-size:18pt">I/O</span></font><font face="宋体" size="5"><span style="font-size:18pt">操作完成。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">同步阻塞</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Blocked on Synchronization)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：等待获取锁。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">死亡</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Dead)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：线程完成了执行。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">14.</span></font><font face="宋体" size="5"><span style="font-size:18pt">同步方法和同步代码块的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">语言中，每一个对象有一把锁。线程可以使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">synchronized</span></font><font face="宋体" size="5"><span style="font-size:18pt">关键字来获取对象上的锁。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">synchronized</span></font><font face="宋体" size="5"><span style="font-size:18pt">关键字可应用在方法级别</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(</span></font><font face="宋体" size="5"><span style="font-size:18pt">粗粒度锁</span></font><font face="Verdana" size="5"><span style="font-size:18pt">)</span></font><font face="宋体" size="5"><span style="font-size:18pt">或者是代码块级别</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(</span></font><font face="宋体" size="5"><span style="font-size:18pt">细粒度锁</span></font><font face="Verdana" size="5"><span style="font-size:18pt">)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">15.</span></font><font face="宋体" size="5"><span style="font-size:18pt">在监视器</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Monitor)</span></font><font face="宋体" size="5"><span style="font-size:18pt">内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">监视器和锁在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">16.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是死锁</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(deadlock)</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">17.</span></font><font face="宋体" size="5"><span style="font-size:18pt">如何确保</span></font><font face="Verdana" size="5"><span style="font-size:18pt">N</span></font><font face="宋体" size="5"><span style="font-size:18pt">个线程可以访问</span></font><font face="Verdana" size="5"><span style="font-size:18pt">N</span></font><font face="宋体" size="5"><span style="font-size:18pt">个资源同时又不导致死锁？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><div><font face="宋体" size="5"><span style="font-size:18pt">使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</span></font></div></div></div></span>
</div></body></html> 