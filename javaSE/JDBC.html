<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1612"/>

<div>
<span><div><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">72.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDBC</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">JDBC</span></font><font face="宋体" size="5"><span style="font-size:18pt">是允许用户在不同数据库之间做选择的一个抽象层。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDBC</span></font><font face="宋体" size="5"><span style="font-size:18pt">允许开发者用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JAVA</span></font><font face="宋体" size="5"><span style="font-size:18pt">写数据库应用程序，而不需要关心底层特定数据库的细节。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">73.</span></font><font face="宋体" size="5"><span style="font-size:18pt">解释下驱动</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Driver)</span></font><font face="宋体" size="5"><span style="font-size:18pt">在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDBC</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的角色。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">JDBC</span></font><font face="宋体" size="5"><span style="font-size:18pt">驱动提供了特定厂商对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDBC API</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口类的实现，驱动必须要提供</span></font><font face="Verdana" size="5"><span style="font-size:18pt">java.sql</span></font><font face="宋体" size="5"><span style="font-size:18pt">包下面这些类的实现：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Connection, Statement, PreparedStatement,CallableStatement, ResultSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Driver</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">74.Class.forName()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法有什么作用？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">这个方法用来载入跟数据库建立连接的驱动。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">75.PreparedStatement</span></font><font face="宋体" size="5"><span style="font-size:18pt">比</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Statement</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么优势？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">PreparedStatements</span></font><font face="宋体" size="5"><span style="font-size:18pt">是预编译的，因此，性能会更好。同时，不同的查询参数值，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">PreparedStatement</span></font><font face="宋体" size="5"><span style="font-size:18pt">可以重用。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">76.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么时候使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">CallableStatement</span></font><font face="宋体" size="5"><span style="font-size:18pt">？用来准备</span></font><font face="Verdana" size="5"><span style="font-size:18pt">CallableStatement</span></font><font face="宋体" size="5"><span style="font-size:18pt">的方法是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">CallableStatement</span></font><font face="宋体" size="5"><span style="font-size:18pt">用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">CallableStatement</span></font><font face="宋体" size="5"><span style="font-size:18pt">的方法是：</span></font></p><div align="left" style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:0.00mm;min-height: 22pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></div><table cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 1px; border-color: #c0c0c0;" width="491"><colgroup><col width="21"></col><col width="469"></col></colgroup><tbody><tr><td align="left" style="border: solid #c0c0c0 1px;" valign="middle" width="20"><div align="left" style="min-height: 20pt;"><font color="#010101" face="����" size="5"><span style="font-size:18pt">1</span></font></div></td><td align="left" style="border: solid #c0c0c0 1px;" valign="middle" width="468"><div align="left" style="min-height: 20pt;"><font color="#010101" face="����" size="5"><span style="font-size:18pt">CallableStament.prepareCall();</span></font></div></td></tr></tbody></table><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">77.</span></font><font face="宋体" size="5"><span style="font-size:18pt">数据库连接池是什么意思？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">远程方法调用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(RMI)</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">78.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">远程方法调用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Java RMI)</span></font><font face="宋体" size="5"><span style="font-size:18pt">是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java API</span></font><font face="宋体" size="5"><span style="font-size:18pt">对远程过程调用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(RPC)</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供的面向对象的等价形式，支持直接传输序列化的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">的一些注意事项。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">79.RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">体系结构的基本原则是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">允许定义行为的代码和实现行为的代码相分离，并且运行在不同的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">上。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">80.RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">体系结构分哪几层？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">体系结构分以下几层：</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">存根和骨架层</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Stub and Skeleton layer)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">服务。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">远程引用层</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Remote Reference Layer)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">传输层</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Transport layer)</span></font><font face="宋体" size="5"><span style="font-size:18pt">：这一层负责连接参与服务的两个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">。这一层是建立在网络上机器间的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">TCP/IP</span></font><font face="宋体" size="5"><span style="font-size:18pt">连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">81.RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的远程接口</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Remote Interface)</span></font><font face="宋体" size="5"><span style="font-size:18pt">扮演了什么样的角色？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">82.java.rmi.Naming</span></font><font face="宋体" size="5"><span style="font-size:18pt">类扮演了什么样的角色？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">java.rmi.Naming</span></font><font face="宋体" size="5"><span style="font-size:18pt">类用来存储和获取在远程对象注册表里面的远程对象的引用。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Naming</span></font><font face="宋体" size="5"><span style="font-size:18pt">类的每一个方法接收一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">URL</span></font><font face="宋体" size="5"><span style="font-size:18pt">格式的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">String</span></font><font face="宋体" size="5"><span style="font-size:18pt">对象作为它的参数。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">83.RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">的绑定</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Binding)</span></font><font face="宋体" size="5"><span style="font-size:18pt">是什么意思？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Naming</span></font><font face="宋体" size="5"><span style="font-size:18pt">类的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">bind()</span></font><font face="宋体" size="5"><span style="font-size:18pt">或者</span></font><font face="Verdana" size="5"><span style="font-size:18pt">rebind()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法跟名称相关联。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">84.Naming</span></font><font face="宋体" size="5"><span style="font-size:18pt">类的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">bind()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">rebind()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">bind()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法负责把指定名称绑定给远程对象，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">rebind()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">85.</span></font><font face="宋体" size="5"><span style="font-size:18pt">让</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">程序能正确运行有哪些步骤？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">为了让</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">程序能正确运行必须要包含以下几个步骤：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">编译所有的源文件。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">rmic</span></font><font face="宋体" size="5"><span style="font-size:18pt">生成</span></font><font face="Verdana" size="5"><span style="font-size:18pt">stub</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">启动</span></font><font face="Verdana" size="5"><span style="font-size:18pt">rmiregistry</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">启动</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">服务器。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">运行客户端程序。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">86.RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">stub</span></font><font face="宋体" size="5"><span style="font-size:18pt">扮演了什么样的角色？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">远程对象的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">stub</span></font><font face="宋体" size="5"><span style="font-size:18pt">扮演了远程对象的代表或者代理的角色。调用者在本地</span></font><font face="Verdana" size="5"><span style="font-size:18pt">stub</span></font><font face="宋体" size="5"><span style="font-size:18pt">上调用方法，它负责在远程对象上执行方法。当</span></font><font face="Verdana" size="5"><span style="font-size:18pt">stub</span></font><font face="宋体" size="5"><span style="font-size:18pt">的方法被调用的时候，会经历以下几个步骤：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">初始化到包含了远程对象的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">的连接。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">序列化参数到远程的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">等待方法调用和执行的结果。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">反序列化返回的值或者是方法没有执行成功情况下的异常。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">把值返回给调用者。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">87.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是分布式垃圾回收</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(DGC)</span></font><font face="宋体" size="5"><span style="font-size:18pt">？它是如何工作的？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">DGC</span></font><font face="宋体" size="5"><span style="font-size:18pt">叫做分布式垃圾回收。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">DGC</span></font><font face="宋体" size="5"><span style="font-size:18pt">来做自动垃圾回收。因为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">DGC</span></font><font face="宋体" size="5"><span style="font-size:18pt">使用引用计数算法来给远程对象提供自动内存管理。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">88.RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">中使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">安全管理器</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(RMISecurityManager)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的目的是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">RMISecurityManager</span></font><font face="宋体" size="5"><span style="font-size:18pt">使用下载好的代码提供可被</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">应用程序使用的安全管理器。如果没有设置安全管理器，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">RMI</span></font><font face="宋体" size="5"><span style="font-size:18pt">的类加载器就不会从远程下载任何的类。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">89.</span></font><font face="宋体" size="5"><span style="font-size:18pt">解释下</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Marshalling</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">demarshalling</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Marshalling</span></font><font face="宋体" size="5"><span style="font-size:18pt">，反之就是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">demarshalling</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">90.</span></font><font face="宋体" size="5"><span style="font-size:18pt">解释下</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Serialization</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Deserialization</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><div><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</span></font></div></div></div></span>
</div></body></html> 