<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1604"/>

<div>
<span><div><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">18.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类框架的基本接口有哪些？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类里面最基本的接口有：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Collection</span></font><font face="宋体" size="5"><span style="font-size:18pt">：代表一组对象，每一个对象都是它的子元素。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Set</span></font><font face="宋体" size="5"><span style="font-size:18pt">：不包含重复元素的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Collection</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">：有顺序的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">collection</span></font><font face="宋体" size="5"><span style="font-size:18pt">，并且可以包含重复元素。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Map</span></font><font face="宋体" size="5"><span style="font-size:18pt">：可以把键</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(key)</span></font><font face="宋体" size="5"><span style="font-size:18pt">映射到值</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(value)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的对象，键不能重复。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">19.</span></font><font face="宋体" size="5"><span style="font-size:18pt">为什么集合类没有实现</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Cloneable</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Serializable</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">克隆</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(cloning)</span></font><font face="宋体" size="5"><span style="font-size:18pt">或者是序列化</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(serialization)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">20.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是迭代器</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Iterator)</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:4.22mm;min-height: 13pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 11pt;"><font face="宋体" size="5"><span style="font-size:18pt">迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">21.Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">下面列出了他们的区别：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">可用来遍历</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Set</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合，但是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">只能用来遍历</span></font><font face="Verdana" size="5"><span style="font-size:18pt">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">对集合只能是前向遍历，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">既可以前向也可以后向。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">ListIterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">实现了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">22.</span></font><font face="宋体" size="5"><span style="font-size:18pt">快速失败</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(fail-fast)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和安全失败</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(fail-safe)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">java.util</span></font><font face="宋体" size="5"><span style="font-size:18pt">包下面</span></font><font face="Verdana" size="5"><span style="font-size:18pt">      </span></font> <font face="宋体" size="5"><span style="font-size:18pt">的所有的集合类都是快速失败的，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">java.util.concurrent</span></font><font face="宋体" size="5"><span style="font-size:18pt">包下面的所有的类都是安全失败的。快速失败的迭代器会抛出</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">ConcurrentModificationException</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常，而安全失败的迭代器永远不会抛出这样的异常。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">23.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">的工作原理是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">是以键值对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(key-value)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的形式存储元素的。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">需要一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">函数，它使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法来向集合</span></font><font face="Verdana" size="5"><span style="font-size:18pt">/</span></font><font face="宋体" size="5"><span style="font-size:18pt">从集合添加和检索元素。当调用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">put()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的时候，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">会计算</span></font><font face="Verdana" size="5"><span style="font-size:18pt">key</span></font><font face="宋体" size="5"><span style="font-size:18pt">的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">值，然后把键值对存储在集合中合适的索引上。如果</span></font><font face="Verdana" size="5"><span style="font-size:18pt">key</span></font><font face="宋体" size="5"><span style="font-size:18pt">已经存在了，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">value</span></font><font face="宋体" size="5"><span style="font-size:18pt">会被更新成新值。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">的一些重要的特性是它的容量</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(capacity)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，负载因子</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(load factor)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和扩容极限</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(threshold resizing)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">24.hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的重要性体现在什么地方？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">的精确性和正确性是至关重要的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">25.HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">都实现了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Map</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口，因此很多特性非常相似。但是，他们有以下不同点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">允许键和值是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">不允许键或者值是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">是同步的，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">不是。因此，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">更适合于单线程环境，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">适合于多线程环境。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了可供应用迭代的键的集合，因此，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">HashMap</span></font><font face="宋体" size="5"><span style="font-size:18pt">是快速失败的。另一方面，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了对键的列举</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Enumeration)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: circle;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-family: Courier New; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">一般认为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Hashtable</span></font><font face="宋体" size="5"><span style="font-size:18pt">是一个遗留的类。</span></font></li></ul></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">26.</span></font><font face="宋体" size="5"><span style="font-size:18pt">数组</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Array)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和列表</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(ArrayList)</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？什么时候应该使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">而不是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">下面列出了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">的不同点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">可以包含基本类型和对象类型，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">只能包含对象类型。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">大小是固定的，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">的大小是动态变化的。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了更多的方法和特性，比如：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">addAll()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">removeAll()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">iterator()</span></font><font face="宋体" size="5"><span style="font-size:18pt">等等。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">27.ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">都实现了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">List</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口，他们有以下的不同点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">是基于索引的数据接口，它的底层是数组。它可以以</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(1)</span></font><font face="宋体" size="5"><span style="font-size:18pt">时间复杂度对元素进行随机访问。与此对应，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">相对于</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">比</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">更占内存，因为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">也可以参考</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList vs. LinkedList</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">28.Comparable</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口是干什么的？列出它们的区别。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了只包含一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">compareTo()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Comparable</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口。这个方法可以个给两个对象排序。具体来说，它返回负数，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">0</span></font><font face="宋体" size="5"><span style="font-size:18pt">，正数来表明输入对象小于，等于，大于已经存在的对象。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供了包含</span></font><font face="Verdana" size="5"><span style="font-size:18pt">compare()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">两个方法的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">compare()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法用来给两个输入参数排序，返回负数，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">0</span></font><font face="宋体" size="5"><span style="font-size:18pt">，正数表明第一个参数是小于，等于，大于第二个参数。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法需要一个对象作为参数，它用来决定输入参数是否和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">相等。只有当输入参数也是一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">并且输入参数和当前</span></font><font face="Verdana" size="5"><span style="font-size:18pt">comparator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的排序结果是相同的时候，这个方法才返回</span></font><font face="Verdana" size="5"><span style="font-size:18pt">true</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">29.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">优先级队列</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Priority Queue)</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">PriorityQueue</span></font><font face="宋体" size="5"><span style="font-size:18pt">是一个基于优先级堆的无界队列，它的元素是按照自然顺序</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(natural order)</span></font><font face="宋体" size="5"><span style="font-size:18pt">排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">PriorityQueue</span></font><font face="宋体" size="5"><span style="font-size:18pt">不允许</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">PriorityQueue</span></font><font face="宋体" size="5"><span style="font-size:18pt">不是线程安全的，入队和出队的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(log(n))</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">30.</span></font><font face="宋体" size="5"><span style="font-size:18pt">你了解大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(big-O notation)</span></font><font face="宋体" size="5"><span style="font-size:18pt">么？你能给出不同数据结构的例子么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:4.22mm;min-height: 13pt;"><font face="宋体" size="5"><span style="font-size:18pt">大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 14pt;"><font face="宋体" size="5"><span style="font-size:18pt">大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号基于时间，内存和性能来选择最好的实现。大</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O</span></font><font face="宋体" size="5"><span style="font-size:18pt">符号可以对大量数据的性能给出一个很好的说明。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">31.</span></font><font face="宋体" size="5"><span style="font-size:18pt">如何权衡是使用无序的数组还是有序的数组？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">有序数组最大的好处在于查找的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(log n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，而无序数组是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。有序数组的缺点是插入操作的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(n)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(1)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">32.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">集合类框架的最佳实践有哪些？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Array</span></font><font face="宋体" size="5"><span style="font-size:18pt">而不是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ArrayList</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">值或者是扩容。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">ClassCastException</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">使用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDK</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供的不变类</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(immutable class)</span></font><font face="宋体" size="5"><span style="font-size:18pt">作为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Map</span></font><font face="宋体" size="5"><span style="font-size:18pt">的键可以避免为我们自己的类实现</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hashCode()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">equals()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">编程的时候接口优于实现。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">底层的集合实际上是空的情况下，返回长度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">0</span></font><font face="宋体" size="5"><span style="font-size:18pt">的集合或者是数组，不要返回</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">33.Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口的区别有哪些？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">速度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">2</span></font><font face="宋体" size="5"><span style="font-size:18pt">倍，同时占用更少的内存。但是，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">远远比</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">安全，因为其他线程不能够修改正在被</span></font><font face="Verdana" size="5"><span style="font-size:18pt">iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">遍历的集合里面的对象。同时，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Iterator</span></font><font face="宋体" size="5"><span style="font-size:18pt">允许调用者删除底层集合里面的元素，这对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Enumeration</span></font><font face="宋体" size="5"><span style="font-size:18pt">来说是不可能的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">34.HashSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">TreeSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">HashSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">是由一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">hash</span></font><font face="宋体" size="5"><span style="font-size:18pt">表来实现的，因此，它的元素是无序的。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">add()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">remove()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">contains()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(1)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><div><font face="宋体" size="5"><span style="font-size:18pt">另一方面，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">TreeSet</span></font><font face="宋体" size="5"><span style="font-size:18pt">是由一个树形的结构来实现的，它里面的元素是有序的。因此，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">add()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">remove()</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">contains()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的时间复杂度是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">O(logn)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></div></div></div></span>
</div></body></html> 