<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1600"/>

<div>
<span><div><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">代码开发模块化</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font><font face="宋体" size="5"><span style="font-size:18pt">，更易维护和修改。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">代码复用。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">增强代码的可靠性和灵活性。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">增加代码的可理解性。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>封装</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">当中，有</span></font><font face="Verdana" size="5"><span style="font-size:18pt">3</span></font><font face="宋体" size="5"><span style="font-size:18pt">种修饰符：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">public</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">private</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">protected</span></font><font face="宋体" size="5"><span style="font-size:18pt">。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">下面列出了使用封装的一些好处：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">通过隐藏对象的属性来保护对象内部的状态。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">禁止对象之间的不良交互提高模块化。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">参考这个文档获取更多关于封装的细节和示例。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"><br/></span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>多态</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>继承</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>抽象</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>抽象和封装的不同点</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>常见的</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"><b>Java</b></span></font><font face="宋体" size="5"><span style="font-size:18pt"><b>问题</b></span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">1.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机？为什么</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">被称作是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">“</span></font><font face="宋体" size="5"><span style="font-size:18pt">平台无关的编程语言</span></font><font face="Verdana" size="5"><span style="font-size:18pt">”</span></font><font face="宋体" size="5"><span style="font-size:18pt">？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机是一个可以执行</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">字节码的虚拟机进程。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">源文件被编译成能被</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机执行的字节码文件。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">2.JDK</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JRE</span></font><font face="宋体" size="5"><span style="font-size:18pt">的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">运行时环境</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(JRE)</span></font><font face="宋体" size="5"><span style="font-size:18pt">是将要执行</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">程序的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机。它同时也包含了执行</span></font><font face="Verdana" size="5"><span style="font-size:18pt">applet</span></font><font face="宋体" size="5"><span style="font-size:18pt">需要的浏览器插件。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">开发工具包</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(JDK)</span></font><font face="宋体" size="5"><span style="font-size:18pt">是完整的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">软件开发包，包含了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JRE</span></font><font face="宋体" size="5"><span style="font-size:18pt">，编译器和其他的工具</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(</span></font><font face="宋体" size="5"><span style="font-size:18pt">比如：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JavaDoc</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">调试器</span></font><font face="Verdana" size="5"><span style="font-size:18pt">)</span></font><font face="宋体" size="5"><span style="font-size:18pt">，可以让开发者开发、编译、执行</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">应用程序。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">3.”static”</span></font><font face="宋体" size="5"><span style="font-size:18pt">关键字是什么意思？</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中是否可以覆盖</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(override)</span></font><font face="宋体" size="5"><span style="font-size:18pt">一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">private</span></font><font face="宋体" size="5"><span style="font-size:18pt">或者是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">的方法？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">“static”</span></font><font face="宋体" size="5"><span style="font-size:18pt">关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法是编译时静态绑定的。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法跟类的任何实例都不相关，所以概念上不适用。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"><br/></span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">4.</span></font><font face="宋体" size="5"><span style="font-size:18pt">是否可以在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">环境中访问非</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">变量？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">变量在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中是属于类的，它在所有的实例中的值是一样的。当类被</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机载入的时候，会对</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">变量进行初始化。如果你的代码尝试不用实例来访问非</span></font><font face="Verdana" size="5"><span style="font-size:18pt">static</span></font><font face="宋体" size="5"><span style="font-size:18pt">的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">5.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">支持的数据类型有哪些？什么是自动拆装箱？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">语言支持的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">8</span></font><font face="宋体" size="5"><span style="font-size:18pt">中基本数据类型是：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">byte</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">short</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">int</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">long</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">float</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">double</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">boolean</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">char</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">自动装箱是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把</span></font><font face="Verdana" size="5"><span style="font-size:18pt">int</span></font><font face="宋体" size="5"><span style="font-size:18pt">转化成</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Integer</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">double</span></font><font face="宋体" size="5"><span style="font-size:18pt">转化成</span></font><font face="Verdana" size="5"><span style="font-size:18pt">double</span></font><font face="宋体" size="5"><span style="font-size:18pt">，等等。反之就是自动拆箱。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">6.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的方法覆盖</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Overriding)</span></font><font face="宋体" size="5"><span style="font-size:18pt">和方法重载</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Overloading)</span></font><font face="宋体" size="5"><span style="font-size:18pt">是什么意思？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">7.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">编译器会为这个类创建一个默认的构造函数。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">不支持像</span></font><font face="Verdana" size="5"><span style="font-size:18pt">C++</span></font><font face="宋体" size="5"><span style="font-size:18pt">中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">不会创建默认的复制构造函数。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">8.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">支持多继承么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">不支持，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">9.</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口和抽象类的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span></font></p><ul style="margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;list-style-type: disc;"><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">类可以实现很多个接口，但是只能继承一个抽象类</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">抽象类可以在不提供接口方法实现的情况下实现接口。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口中声明的变量默认都是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">final</span></font><font face="宋体" size="5"><span style="font-size:18pt">的。抽象类可以包含非</span></font><font face="Verdana" size="5"><span style="font-size:18pt">final</span></font><font face="宋体" size="5"><span style="font-size:18pt">的变量。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="Verdana" size="5"><span style="font-size:18pt; font-family:Verdana; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">接口中的成员函数默认是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">public</span></font><font face="宋体" size="5"><span style="font-size:18pt">的。抽象类的成员函数可以是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">private</span></font><font face="宋体" size="5"><span style="font-size:18pt">，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">protected</span></font><font face="宋体" size="5"><span style="font-size:18pt">或者是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">public</span></font><font face="宋体" size="5"><span style="font-size:18pt">。</span></font></li><li style="margin-left: 32pt; margin-right: 0pt; padding-left: -18pt; text-indent:0pt; font-size: 10pt;"><font face="宋体" size="5"><span style="font-size:18pt; font-family:����; color:#000000; font-weight:Normal; font-style:Normal; font-decoration:Normal">接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含</span></font><font face="Verdana" size="5"><span style="font-size:18pt">main</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法的话是可以被调用的。</span></font></li></ul><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">也可以参考</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JDK8</span></font><font face="宋体" size="5"><span style="font-size:18pt">中抽象类和接口的区别</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">10.</span></font><font face="宋体" size="5"><span style="font-size:18pt">什么是值传递和引用传递？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><div><font face="宋体" size="5"><span style="font-size:18pt">对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</span></font></div></div></div></span>
</div></body></html> 