<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1606"/>

<div>
<span><div><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">35.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中垃圾回收有什么目的？什么时候进行垃圾回收？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">36.System.gc()</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Runtime.gc()</span></font><font face="宋体" size="5"><span style="font-size:18pt">会做什么事情？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">这两个方法用来提示</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">37.finalize()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法什么时候被调用？析构函数</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(finalization)</span></font><font face="宋体" size="5"><span style="font-size:18pt">的目的是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">在释放对象占用的内存之前，垃圾收集器会调用对象的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finalize()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法。一般建议在该方法中释放对象持有的资源。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">38.</span></font><font face="宋体" size="5"><span style="font-size:18pt">如果对象的引用被置为</span></font><font face="Verdana" size="5"><span style="font-size:18pt">null</span></font><font face="宋体" size="5"><span style="font-size:18pt">，垃圾收集器是否会立即释放对象占用的内存？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">39.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">堆的结构是什么样子的？什么是堆中的永久代</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Perm Gen space)? </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">40.</span></font><font face="宋体" size="5"><span style="font-size:18pt">串行</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(serial)</span></font><font face="宋体" size="5"><span style="font-size:18pt">收集器和吞吐量</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(throughput)</span></font><font face="宋体" size="5"><span style="font-size:18pt">收集器的区别是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(</span></font><font face="宋体" size="5"><span style="font-size:18pt">在现代处理器上需要大概</span></font><font face="Verdana" size="5"><span style="font-size:18pt">100M</span></font><font face="宋体" size="5"><span style="font-size:18pt">左右的内存</span></font><font face="Verdana" size="5"><span style="font-size:18pt">)</span></font><font face="宋体" size="5"><span style="font-size:18pt">就足够了。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">41.</span></font><font face="宋体" size="5"><span style="font-size:18pt">在</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中，对象什么时候可以被垃圾回收？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">42.JVM</span></font><font face="宋体" size="5"><span style="font-size:18pt">的永久代中会发生垃圾回收么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt">垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(Full GC)</span></font><font face="宋体" size="5"><span style="font-size:18pt">。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Full GC</span></font><font face="宋体" size="5"><span style="font-size:18pt">是非常重要的原因。请参考下</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java8</span></font><font face="宋体" size="5"><span style="font-size:18pt">：从永久代到元数据区</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">(</span></font><font face="宋体" size="5"><span style="font-size:18pt">译者注：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java8</span></font><font face="宋体" size="5"><span style="font-size:18pt">中已经移除了永久代，新加了一个叫做元数据区的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">native</span></font><font face="宋体" size="5"><span style="font-size:18pt">内存区</span></font><font face="Verdana" size="5"><span style="font-size:18pt">)</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 17pt;"><font face="宋体" size="5"><span style="font-size:18pt"><b>异常处理</b></span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">43.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中的两种异常类型是什么？他们有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中有两种异常：受检查的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(checked)</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常和不受检查的</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(unchecked)</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用</span></font><font face="Verdana" size="5"><span style="font-size:18pt">throws</span></font><font face="宋体" size="5"><span style="font-size:18pt">语句在方法或者是构造函数上声明。这里有</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常处理的一些小建议。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">44.Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">中</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Exception</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Error</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Exception</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Error</span></font><font face="宋体" size="5"><span style="font-size:18pt">都是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Throwable</span></font><font face="宋体" size="5"><span style="font-size:18pt">的子类。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Exception</span></font><font face="宋体" size="5"><span style="font-size:18pt">用于用户程序可以捕获的异常情况。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Error</span></font><font face="宋体" size="5"><span style="font-size:18pt">定义了不期望被用户程序捕获的异常。</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"><br/></span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">45.throw</span></font><font face="宋体" size="5"><span style="font-size:18pt">和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">throws</span></font><font face="宋体" size="5"><span style="font-size:18pt">有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">throw</span></font><font face="宋体" size="5"><span style="font-size:18pt">关键字用来在程序中明确的抛出异常，相反，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">throws</span></font><font face="宋体" size="5"><span style="font-size:18pt">语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">45.</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常处理的时候，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finally</span></font><font face="宋体" size="5"><span style="font-size:18pt">代码块的重要性是什么？</span></font><font face="Verdana" size="5"><span style="font-size:18pt">(</span></font><font face="宋体" size="5"><span style="font-size:18pt">译者注：作者标题的序号弄错了</span></font><font face="Verdana" size="5"><span style="font-size:18pt">) </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="宋体" size="5"><span style="font-size:18pt">无论是否抛出异常，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finally</span></font><font face="宋体" size="5"><span style="font-size:18pt">代码块总是会被执行。就算是没有</span></font><font face="Verdana" size="5"><span style="font-size:18pt">catch</span></font><font face="宋体" size="5"><span style="font-size:18pt">语句同时又抛出异常的情况下，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finally</span></font><font face="宋体" size="5"><span style="font-size:18pt">代码块仍然会被执行。最后要说的是，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finally</span></font><font face="宋体" size="5"><span style="font-size:18pt">代码块主要用来释放资源，比如：</span></font><font face="Verdana" size="5"><span style="font-size:18pt">I/O</span></font><font face="宋体" size="5"><span style="font-size:18pt">缓冲区，数据库连接。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">46.</span></font><font face="宋体" size="5"><span style="font-size:18pt">异常处理完成以后，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Exception</span></font><font face="宋体" size="5"><span style="font-size:18pt">对象会发生什么变化？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">Exception</span></font><font face="宋体" size="5"><span style="font-size:18pt">对象会在下一个垃圾回收过程中被回收掉。</span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 16pt;"><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><p style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><font face="Verdana" size="5"><span style="font-size:18pt">47.finally</span></font><font face="宋体" size="5"><span style="font-size:18pt">代码块和</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finalize()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法有什么区别？</span></font><font face="Verdana" size="5"><span style="font-size:18pt"> </span></font></p><div style="margin-left:0mm; margin-right:0mm; text-indent:0mm; margin-top:2.02mm; margin-bottom:2.02mm;min-height: 20pt;"><div><font face="宋体" size="5"><span style="font-size:18pt">无论是否抛出异常，</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finally</span></font><font face="宋体" size="5"><span style="font-size:18pt">代码块都会执行，它主要是用来释放应用占用的资源。</span></font><font face="Verdana" size="5"><span style="font-size:18pt">finalize()</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法是</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Object</span></font><font face="宋体" size="5"><span style="font-size:18pt">类的一个</span></font><font face="Verdana" size="5"><span style="font-size:18pt">protected</span></font><font face="宋体" size="5"><span style="font-size:18pt">方法，它是在对象被垃圾回收之前由</span></font><font face="Verdana" size="5"><span style="font-size:18pt">Java</span></font><font face="宋体" size="5"><span style="font-size:18pt">虚拟机来调用的。</span></font></div></div></div></span>
</div></body></html> 