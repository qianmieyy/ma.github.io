<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1536"/>

<div>
<span><div><div>Request对象与Response对象</div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><img src="reqresp_files/Image.png" type="image/png" alt="graphic"/></div></td></tr></table><div>服务器处理请求的流程：</div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div>（1）服务器每次收到请求时，都会为这个请求开辟一个新的线程。
<div><br/></div>
（2）服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体！
<div><br/></div>
（3）服务器还会创建response对象，这个对象与客户端连接在一起，它可以用来向客户端发送响应。<br/>
由流程图可以看出，在JavaWeb的请求与响应中，最重要的两个参数为request以及response，这两参数在Servlet的service( )方法中。</div></td></tr></table><div>首先看看Request</div><div><br/></div><div><b>1</b><b>、</b><b>request</b><b>概述</b></div><div><br/></div><div>request是Servlet.service()方法的一个参数，类型为javax.servlet.http.HttpServletRequest。<b>在客户端发出每个请求时，服务器都会创建一个</b><b>request</b><b>对象，并把请求数据封装到</b><b>request</b><b>中，然后在调用</b><b>Servlet.service()</b><b>方法时传递给</b><b>service()</b><b>方法，这说明在</b><b>service()</b><b>方法中可以通过</b><b>request</b><b>对象来获取请求数据</b>。</div><div><br/></div><div><img src="reqresp_files/Image [1].png" type="image/png" alt="graphic"/></div><div><b>request</b><b>的功能可以分为以下几种：</b></div><div><br/></div><div>（1）封装了请求头数据；</div><div><br/></div><div>（2）封装了请求正文数据，如果是GET请求，那么就没有正文；</div><div><br/></div><div>（3）request是一个域对象，可以把它当成Map来添加获取数据；</div><div><br/></div><div>（4）request提供了请求转发和请求包含功能。</div><div><br/></div><div><b>2</b><b>、</b><b>request</b><b>域方法</b></div><div><br/></div><div>request是域对象！在JavaWeb中一共四个域对象，其中ServletContext就是域对象，它在整个应用中只创建一个ServletContext对象。request其中一个，request可以在一个请求中共享数据。</div><div><br/></div><div>一个请求会创建一个request对象，如果在一个请求中经历了多个Servlet，那么多个Servlet就可以使用request来共享数据。现在我们还不知道如何在一个请求中经历几个Servlet。</div><div><br/></div><div>下面是request的域方法：</div><div><br/></div><div>（1）<b>void setAttribute(String name, Object value)</b><b>：</b>用来存储一个对象，也可以称之为存储一个域属性，例如：servletContext.setAttribute(“xxx”, “XXX”)，在request中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同；</div><div><br/></div><div>（2）<b>Object getAttribute(String name)</b><b>：</b>用来获取request中的数据，当前在获取之前需要先去存储才行，例如：String value = (String)request.getAttribute(“xxx”);，获取名为xxx的域属性；</div><div><br/></div><div>（3）<b>void removeAttribute(String name)</b><b>：</b>用来移除request中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做；</div><div><br/></div><div>（4）<b>Enumeration getAttributeNames()</b><b>：</b>获取所有域属性的名称；</div><div><br/></div><div><b>3</b><b>、</b><b>request</b><b>获取请求头数据</b></div><div><br/></div><div><b>request</b><b>与请求头相关的方法有：</b></div><div><br/></div><div>String getHeader(String name)：获取指定名称的请求头；</div><div><br/></div><div>Enumeration getHeaderNames()：获取所有请求头名称；</div><div><br/></div><div>int getIntHeader(String name)：获取值为int类型的请求头。</div><div><br/></div><div><b>4</b><b>　</b><b>request</b><b>获取请求相关的其它方法</b></div><div><br/></div><div>request中还提供了与请求相关的其他方法，有些方法是为了我们更加便捷的方法请求头数据而设计，有些是与请求URL相关的方法。</div><div><div><br/></div>
int getContentLength()：获取请求体的字节数，GET请求没有请求体，没有请求体返回-1；l</div><div><div><br/></div>
String getContentType()：获取请求类型，如果请求是GET，那么这个方法返回null；如果是POST请求，那么默认为application/x- www-form-urlencoded，表示请求体内容使用了URL编码；l</div><div><div><br/></div>
String getMethod()：返回请求方法，例如：GETl</div><div><div><br/></div>
Locale getLocale()：返回当前客户端浏览器的Locale。java.util.Locale表示国家和言语，这个东西在国际化中很有用；l</div><div><div><br/></div>
String getCharacterEncoding()：获取请求编码，如果没有setCharacterEncoding()，那么返回null，表示使用ISO-8859-1编码；l</div><div><div><br/></div>
void setCharacterEncoding(String code)：设置请求编码，只对请求体有效！注意，对于GET而言，没有请求体！！！所以此方法只能对POST请求中的参数有效！l</div><div><div><br/></div>
String getContextPath()：返回上下文路径，例如：/hellol</div><div><div><br/></div>
String getQueryString()：返回请求URL中的参数，例如：name=zhangSanl</div><div><div><br/></div>
String getRequestURI()：返回请求URI路径，例如：/hello/oneServletl</div><div><div><br/></div>
StringBuffer getRequestURL()：返回请求URL路径，例如：http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；l</div><div><div><br/></div>
String getServletPath()：返回Servlet路径，例如：/oneServletl</div><div><div><br/></div>
String getRemoteAddr()：返回当前客户端的IP地址；l</div><div><div><br/></div>
String getRemoteHost()：返回当前客户端的主机名，但这个方法的实现还是获取IP地址；l</div><div><div><br/></div>
String getScheme()：返回请求协议，例如：http；l</div><div><div><br/></div>
String getServerName()：返回主机名，例如：localhostl</div><div><div><br/></div>
int getServerPort()：返回服务器端口号，例如：8080l</div><div><br/></div><div><b>5</b><b>　</b><b>request</b><b>获取请求参数</b></div><div><br/></div><div>最为常见的客户端传递参数方式有两种：</div><div><br/></div><div>浏览器地址栏直接输入：一定是GET请求；</div><div><br/></div><div>超链接：一定是GET请求；</div><div><br/></div><div>表单：可以是GET，也可以是POST，这取决与&lt;form&gt;的method属性值；</div><div><br/></div><div><br/></div><div>GET请求和POST请求的区别：</div><div><br/></div><div>GET请求：</div><div><br/></div><div>请求参数会在浏览器的地址栏中显示，所以不安全；</div><div><br/></div><div>请求参数长度限制长度在1K之内；</div><div><br/></div><div>GET请求没有请求体，无法通过request.setCharacterEncoding()来设置参数的编码；</div><div><br/></div><div>POST请求：</div><div><br/></div><div>请求参数不会显示浏览器的地址栏，相对安全；</div><div><br/></div><div>请求参数长度没有限制；</div><div><br/></div><div>下面是使用request获取请求参数的API：</div><div><br/></div><div>l  String getParameter(String name)：通过指定名称获取参数值；</div><div><br/></div><div>l  String[] getParameterValues(String name)：当多个参数名称相同时，可以使用方法来获取；</div><div><br/></div><div>l  Enumeration getParameterNames()：获取所有参数的名字；</div><div><br/></div><div>l  Map getParameterMap()：获取所有参数封装到Map中，其中key为参数名，value为参数值，因为一个参数名称可能有多个值，所以参数值是String[]，而不是String。</div><div><br/></div><div><b>6</b><b>、请求转发和请求包含</b><b>（</b><b>*****</b><b>重点</b><b>*****</b><b>）</b></div><div><br/></div><div>无论是请求转发还是请求包含，都表示由多个Servlet共同来处理一个请求。例如Servlet1来处理请求，然后Servlet1又转发给Servlet2来继续处理这个请求。</div><div><br/></div><div>请求转发和请求包含</div><div><div><br/></div>
RequestDispatcher rd = request.getRequestDispatcher(&quot;/MyServlet&quot;);  使用request获取RequestDispatcher对象，方法的参数是被转发或包含的Servlet的Servlet路径</div><div><br/></div><div><b>请求转发：</b><b>rd.forward(request,response);</b></div><div><div><br/></div>
请求包含：rd.include(request,response);</div><div><br/></div><div><div><br/></div>
有时一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet跳到另一个Servlet！</div><div><div><br/></div>
    &gt; 一个请求跨多个Servlet，需要使用转发和包含。</div><div><div><br/></div>
　&gt; 请求转发：由下一个Servlet完成响应体！当前Servlet可以设置响应头！<b>（留头不留体）</b></div><div><br/></div><div>即当前Servlet设置的相应头有效，相应体无效。</div><div><div><br/></div>
    &gt; 请求包含：由两个Servlet共同未完成响应体！<b>（留头又留体）</b>                                                                     都有效。<br/></div><div><div><br/></div>
    &gt; 无论是请求转发还是请求包含，都在一个请求范围内！使用同一个request和response！</div><div><div><br/></div><br/></div><div><b>请求转发与请求包含比较：</b></div><div><br/></div><div>（1）如果在AServlet中请求转发到BServlet，那么在AServlet中就不允许再输出响应体，即不能再使用response.getWriter()和response.getOutputStream()向客户端输出，这一工作应该由BServlet来完成；如果是使用请求包含，那么没有这个限制；</div><div><br/></div><div>（2）请求转发虽然不能输出响应体，但还是可以设置响应头的，例如：response.setContentType(”text/html;charset=utf-8”);</div><div><br/></div><div><b>（</b><b>3</b><b>）请求包含大多是应用在</b><b>JSP</b><b>页面中，完成多页面的合并；</b></div><div><br/></div><div><b>（</b><b>4</b><b>）请求转发大多是应用在</b><b>Servlet</b><b>中，转发目标大多是</b><b>JSP</b><b>页面；</b></div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><img src="reqresp_files/Image [2].png" type="image/png" alt="graphic"/></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><b>请求转发与重定向比较</b><br/>
（1）请求转发是一个请求，而重定向是两个请求；（2）请求转发后浏览器地址栏不会有变化，而重定向会有变化，因为重定向是两个请求；（3）请求转发的目标只能是本应用中的资源，重定向的目标可以是其他应用；（4）请求转发对AServlet和BServlet的请求方法是相同的，即要么都是GET，要么都是POST，因为请求转发是一个请求；（5）重定向的第二个请求一定是GET；<br/></div></td></tr></table><div><br/></div><div>Response</div><div><br/></div><div><b>1</b><b>、</b><b>response</b><b>概念：</b></div><div><br/></div><div>         response是Servlet.service方法的一个参数，类型为javax.servlet.http.HttpServletResponse。在客户端发出每个请求时，服务器都会创建一个response对象，并传入给Servlet.service()方法。response对象是用来对客户端进行响应的，这说明<b>在</b><b>service()</b><b>方法中使用</b><b>response</b><b>对象可以完成对客户端的响应工作。</b></div><div><br/></div><div><b>response</b><b>对象的功能分为以下四种：</b></div><div><br/></div><div>（1）设置响应头信息</div><div><br/></div><div>（2）发送状态码</div><div><br/></div><div>（3）设置响应正文</div><div><br/></div><div><b>（</b><b>4</b><b>）重定向</b></div><div><br/></div><div><b>2</b><b>、</b><b>response</b><b>响应正文</b></div><div><br/></div><div>response是响应对象，向客户端输出响应正文（响应体）可以使用response的响应流，repsonse一共提供了两个响应流对象：</div><div><br/></div><div>（1）<b>PrintWriter </b>out = response.getWriter()：获取字符流；</div><div><br/></div><div>（2）<b>ServletOutputStream</b>out = response.getOutputStream()：获取字节流；<br/></div><div><br/></div><div>当然，如果响应正文内容为字符，那么使用response.getWriter()，如果响应内容是字节，例如下载时，那么可以使用response.getOutputStream()。</div><div><br/></div><div><b>注意，在一个请求中，不能同时使用这两个流！也就是说，要么你使用</b><b>repsonse.getWriter()</b><b>，要么使用</b><b>response.getOutputStream()</b><b>，但不能同时使用这两个流。不然会抛出</b><b>illegalStateException</b><b>异常。</b></div><div><br/></div><div><b>2.1</b><b>　字符响应流</b></div><div><br/></div><div>字符编码</div><div><br/></div><div>在使用response.getWriter()时需要注意默认字符编码为ISO-8859-1，如果希望设置字符流的字符编码为utf-8，可以使用response.setCharaceterEncoding(“utf-8”)来设置。这样可以保证输出给客户端的字符都是使用UTF-8编码的！</div><div><br/></div><div>但客户端浏览器并不知道响应数据是什么编码的！如果希望通知客户端使用UTF-8来解读响应数据，那么还是使用response.setContentType(&quot;text/html;charset=utf-8&quot;)方法比较好，因为这个方法不只会调用response.setCharaceterEncoding(“utf-8”)，还会设置content-type响应头，客户端浏览器会使用content-type头来解读响应数据。<br/></div><div>缓冲区</div><div><br/></div><div>response.getWriter()是PrintWriter类型，所以它有缓冲区，缓冲区的默认大小为8KB。也就是说，在响应数据没有输出8KB之前，数据都是存放在缓冲区中，而不会立刻发送到客户端。当Servlet执行结束后，服务器才会去刷新流，使缓冲区中的数据发送到客户端。</div><div><br/></div><div>如果希望响应数据马上发送给客户端：</div><div><br/></div><div> 向流中写入大于8KB的数据；</div><div><br/></div><div> 调用response.flushBuffer()方法来手动刷新缓冲区</div><div><br/></div><div><b>3</b><b>、设置响应头信息</b></div><div><br/></div><div><b>可以使用</b><b>response</b><b>对象的</b><b>setHeader()</b><b>方法来设置响应头！</b></div><div><br/></div><div>使用该方法设置的响应头最终会发送给客户端浏览器！</div><div><br/></div><div>（1）response.setHeader(“content-type”, “text/html;charset=utf-8”)：设置content-type响应头，该头的作用是告诉浏览器响应内容为html类型，编码为utf-8。而且同时会设置response的字符流编码为utf-8，即response.setCharaceterEncoding(“utf-8”)；</div><div><br/></div><div>（2）response.setHeader(&quot;Refresh&quot;,&quot;5; URL=http://www.baidu.com&quot;)：5秒后自动跳转到百度主页。</div><div><br/></div><div><b>4</b><b>、设置状态码及其他方法</b></div><div><br/></div><div><b>（</b><b>1</b><b>）</b><b>response.setContentType(&quot;text/html;charset=utf-8&quot;)</b><b>：等同与调用</b><b>response.setHeader(“content-type”, “text/html;charset=utf-8”)</b><b>；</b></div><div><br/></div><div><b>（</b><b>2</b><b>）</b><b>response.setCharacterEncoding(“utf-8”)</b><b>：设置字符响应流的字符编码为</b><b>utf-8</b><b>；</b></div><div><br/></div><div><b>（</b><b>3</b><b>）</b><b>response.setStatus(200)</b><b>：设置状态码；</b></div><div><br/></div><div>（4）response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。</div><div><br/></div><div><b>5</b><b>、重定向</b><b>（</b><b>*****</b><b>重点</b><b>*****</b><b>）</b></div><div><br/></div><div><b>5.1</b><b>　什么是重定向（两次请求）</b></div><div><br/></div><div>当你访问http://www.sun.com时，你会发现浏览器地址栏中的URL会变成http://www.<b><a href="http://lib.csdn.net/base/oracle%20/o%20Oracle%C3%96%C2%AA%C3%8A%C2%B6%C2%BF%C3%A2/t_blank">Oracle</a></b>.com/us/sun/index.htm，这就是重定向了。重定向是服务器通知浏览器去访问另一个地址，即再发出另一个请求。</div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><img src="reqresp_files/Image [3].png" type="image/png" alt="graphic"/></div></td></tr></table><div><b>5.2</b> <b>如何完成重定向？</b></div><div><br/></div><div>答：<b>重定向的状态码为</b><b>302</b>，我们首先使用response对象向浏览器发送302的状态码，之后再设置一个Location，即给出一个可用的URL，由浏览器去访问新的URL，实现重定向。</div><div><br/></div><div>列：</div><table style="-evernote-table:true;border-collapse:collapse;width:100%;table-layout:fixed;"><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><ol><li><b>public</b><b>class</b> AServlet <b>extends</b> HttpServlet {</li></ol>
     <b>public</b> <b>void</b> doGet(HttpServletRequest request, HttpServletResponse response)            <b>throws</b> ServletException, IOException {        response.setStatus(302);<br/>
        response.setHeader(&quot;Location&quot;, &quot;http://www.baidu.com&quot;);<br/>
    }}<br/></div></td></tr></table><div>上面代码的作用是：当访问AServlet后，会通知浏览器重定向到百度主页。客户端浏览器解析到响应码为302后，就知道服务器让它重定向，所以它会马上获取响应头Location，然发出第二个请求。</div><div><br/></div><div><b>还有一种快捷的重定向方法，即使用</b><b>response.sendRedirect()</b><b>方法。比如上面例子中的两句可以使用</b><b>response.sendRedirect(&quot;http://www.baidu.com&quot;)</b><b>代替。</b></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 